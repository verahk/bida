new_indx_pa <- conf_pa%*%stride_pa
# adjust counts and partition
obj$counts$dim <- obj$counts$dim[perm]
indx_y  <- obj$counts$index%%dims[1]
indx_pa <- obj$counts$index%/%dims[1]
obj$counts$index <- indx_y + dims[1]*(match(indx_pa, new_indx_pa)-1)
obj$partition <- relist(match(unlist(obj$partition), new_indx_pa)-1, obj$partition)
return(obj)
}
bdeu_perm
bdeu_perm <- aperm(bdeu_part, perm)
stopifnot(all.equal(as.array(bdeu_perm$counts), array(1, nlev[perm])))
bdeu_perm
parentnodes
x
x <- 3
z <- 1
y <-
1
parentnodes <- sort.int(c(x, z), index.return = T)
parentnodes
1+seq_along(parentnodes)[parentnodes$ix]
load_all()
#' @export
#'
#' # Categorical data ----
#' nlev <- 2:4
#' lev  <- lapply(nlev-1, seq.int, from = 0)
#' data <- as.matrix(expand.grid(lev))
#'
#' hyperpar <- list(nlev = nlev,  levels = lev, ess = 1)
#'
#'
backdoor_params <- function(type, data, x, y, z, hyperpar, lookup) {
if (type %in% c("cat", "ldag", "tree")) {
if (length(z) > 0 && any(y == z)) {
bida_bdeu(data, y, integer(0), hyperpar$ess, hyperpar$nlev)
} else if (length(z) == 0 || type == "cat") {
bida_bdeu(data, y, c(x, z), hyperpar$ess, hyperpar$nlev)
} else {
if (!is.null(lookup[[type]])) {
parentnodes <- sort.int(c(x, z), index.return = T)
parID <- paste(c(y, parentnodes$x), collapse = ".")
if (parID %in% names(lookup[[type]])) {
bdeu <- lookup[[type]][[parID]]$bdeu
if (parentnodes[1] == x) {
return(bdeu)
} else {
# permute dimension of bdeu object
# the intervention variable x is assumed to be second dim
return(aperm(bdeu, c(1, 1+seq_along(parentnodes)[parentnodes$ix])))
}
}
}
bdeu <- bida_bdeu(data, y, c(x, z), hyperpar$ess, hyperpar$nlev, NULL)
opt  <- optimize_bdeu(bdeu,
method = type,
levels = hyperpar$levels[c(y, x, z)],
regular = hyperpar$regular)
bdeu$partition <- opt$partition
return(bdeu)
}
} else {
stop(paste0("type, ", type, " is not supported."))
}
}
#' nlev <- 2:4
#' lev  <- lapply(nlev-1, seq.int, from = 0)
#' data <- as.matrix(expand.grid(lev))
#'
backdoor_params <- function(type, data, x, y, z, hyperpar, lookup) {
if (type %in% c("cat", "ldag", "tree")) {
if (length(z) > 0 && any(y == z)) {
bida_bdeu(data, y, integer(0), hyperpar$ess, hyperpar$nlev)
} else if (length(z) == 0 || type == "cat") {
bida_bdeu(data, y, c(x, z), hyperpar$ess, hyperpar$nlev)
} else {
if (!is.null(lookup[[type]])) {
parentnodes <- sort.int(c(x, z), index.return = T)
parID <- paste(c(y, parentnodes$x), collapse = ".")
if (parID %in% names(lookup[[type]])) {
bdeu <- lookup[[type]][[parID]]$bdeu
if (parentnodes[1] == x) {
return(bdeu)
} else {
# permute dimension of bdeu object
# the intervention variable x is assumed to be second dim
return(aperm(bdeu, c(1, 1+seq_along(parentnodes)[parentnodes$ix])))
}
}
}
bdeu <- bida_bdeu(data, y, c(x, z), hyperpar$ess, hyperpar$nlev, NULL)
opt  <- optimize_bdeu(bdeu,
method = type,
levels = hyperpar$levels[c(y, x, z)],
regular = hyperpar$regular)
bdeu$partition <- opt$partition
return(bdeu)
}
} else {
stop(paste0("type, ", type, " is not supported."))
}
}
#' nlev <- 2:4
#' lev  <- lapply(nlev-1, seq.int, from = 0)
#' data <- as.matrix(expand.grid(lev))
hyperpar <- list(nlev = nlev,  levels = lev, ess = 1)
#' nlev <- 2:4
#' lev  <- lapply(nlev-1, seq.int, from = 0)
#' data <- as.matrix(expand.grid(lev))
#'
#' hyperpar <- list(nlev = nlev,  levels = lev, ess = 1)
#' Compute parameters for direct backdoor estimation of an intervention distribution
#'
#' @inheritParams bida_pair
#' @param z (integer vector) column position of the adjustment variables.
#'   If `any(y == z)`, the marginal distribution of `y` is returned.
#'   If `length(z) = 0`, the conditional distribution of `y` given `x`.
#' @return
#' - If `type` is in `c("cat", "ldag", "tree")`, an object of class [bida_bdeu].
#' @export
#'
#' # Categorical data ----
#' nlev <- 2:4
#' lev  <- lapply(nlev-1, seq.int, from = 0)
#' data <- as.matrix(expand.grid(lev))
#'
#' hyperpar <- list(nlev = nlev,  levels = lev, ess = 1)
nlev
#' nlev <- 2:4
#' lev  <- lapply(nlev-1, seq.int, from = 0)
#' data <- as.matrix(expand.grid(lev))
#'
#' hyperpar <- list(nlev = nlev,  levels = lev, ess = 1)
nlev
#' @export
#'
#' # Categorical data ----
#' nlev <- 2:4
#' lev  <- lapply(nlev-1, seq.int, from = 0)
#' data <- as.matrix(expand.grid(lev))
#'
#' hyperpar <- list(nlev = nlev,  levels = lev, ess = 1)
#'
#'
backdoor_params <- function(type, data, x, y, z, hyperpar, lookup) {
if (type %in% c("cat", "ldag", "tree")) {
if (length(z) > 0 && any(y == z)) {
bida_bdeu(data, y, integer(0), hyperpar$ess, hyperpar$nlev)
} else if (length(z) == 0 || type == "cat") {
bida_bdeu(data, y, c(x, z), hyperpar$ess, hyperpar$nlev)
} else {
if (!is.null(lookup[[type]])) {
parentnodes <- sort.int(c(x, z), index.return = T)
parID <- paste(c(y, parentnodes$x), collapse = ".")
if (parID %in% names(lookup[[type]])) {
bdeu <- lookup[[type]][[parID]]$bdeu
if (parentnodes[1] == x) {
return(bdeu)
} else {
# permute dimension of bdeu object
# the intervention variable x is assumed to be second dim
return(aperm(bdeu, c(1, 1+seq_along(parentnodes)[parentnodes$ix])))
}
}
}
bdeu <- bida_bdeu(data, y, c(x, z), hyperpar$ess, hyperpar$nlev, NULL)
opt  <- optimize_bdeu(bdeu,
method = type,
levels = hyperpar$levels[c(y, x, z)],
regular = hyperpar$regular)
bdeu$partition <- opt$partition
return(bdeu)
}
} else {
stop(paste0("type, ", type, " is not supported."))
}
}
document()
load_all()
rm(list = c("backdoor_params"))
nlev <- 2:4
lev  <- lapply(nlev-1, seq.int, from = 0)
data <- as.matrix(expand.grid(lev))
hyperpar <- list(nlev = nlev,  levels = lev, ess = 1)
hyperpar
backdoor_params(type, data, 1, 2, integer(0), hyperpar, NULL)
type <- "tree"
backdoor_params(type, data, 1, 2, integer(0), hyperpar, NULL)
backdoor_params(type, data, 1, 2, 3, hyperpar, NULL)
lev
bdeu <- bida_bdeu(data, y, c(x, z), hyperpar$ess, hyperpar$nlev, NULL)
backdoor_params(type, data, y, x, y, hyperpar, NULL)
y <-1
x <- 2
backdoor_params(type, data, y, x, integer(0), hyperpar, NULL)
backdoor_params(type, data, y, x, y, hyperpar, NULL)
backdoor_params(type, data, y, x, integer(0), hyperpar, NULL)
backdoor_params(type, data, y, x, y, hyperpar, NULL)
type %in% c("cat", "ldag", "tree")
z <- y
length(z) > 0 && any(y == z)
bida_bdeu(data, y, integer(0), hyperpar$ess, hyperpar$nlev)
load_all()
backdoor_params(type, data, y, x, y, hyperpar, NULL)
load_all()
backdoor_params(type, data, y, x, y, hyperpar, NULL)
z
y
backdoor_params(type, data, x, y, integer(0), hyperpar, NULL)
backdoor_params(type, data, x, y, y, hyperpar, NULL)
load_all()
backdoor_params(type, data, x, y, y, hyperpar, NULL)
load_all()
backdoor_params(type, data, x, y, y, hyperpar, NULL)
backdoor_params(type, data, y, x, 3, hyperpar, NULL)
ncol(data)
z
z <- 3
length(z) == 0 || type == "cat"
bida_bdeu(data, y, c(x, z), hyperpar$ess, hyperpar$nlev)
if (!is.null(lookup[[type]])) {
parentnodes <- sort.int(c(x, z), index.return = T)
parID <- paste(c(y, parentnodes$x), collapse = ".")
if (parID %in% names(lookup[[type]])) {
bdeu <- lookup[[type]][[parID]]$bdeu
if (parentnodes[1] == x) {
return(bdeu)
} else {
# permute dimension of bdeu object
# the intervention variable x is assumed to be second dim
return(aperm(bdeu, c(1, 1+seq_along(parentnodes)[parentnodes$ix])))
}
}
}
bdeu <- bida_bdeu(data, y, c(x, z), hyperpar$ess, hyperpar$nlev, NULL)
hyperpar$levels[c(y, x, z)]
opt  <- optimize_bdeu(bdeu,
method = type,
levels = hyperpar$levels[c(y, x, z)],
regular = hyperpar$regular)
optimize_bdeu
opt  <- optimize_bdeu(bdeu,
method = type,
levels = hyperpar$levels[c(x, z)],
regular = hyperpar$regular)
load_all()
backdoor_params(type, data, y, x, 3, hyperpar, NULL)
hyperpar <- list(nlev = nlev,  levels = lev, ess = 1, regular = FALSE)
backdoor_params(type, data, y, x, 3, hyperpar, NULL)
backdoor_params(type, data, x, y, c(y, 3), hyperpar, NULL)
lookup   <- rlang:::new_environment()
lookup   <- rlang:::new_environment()
scorepar <- define_scoreparameters(data, "tree", hyperpar, lookup = lookupe)
scorepar <- define_scoreparameters(data, "tree", hyperpar, lookup = lookup)
type <- "tree"
lookup   <- rlang:::new_environment()
scorepar <- define_scoreparameters(data, "tree", hyperpar, lookup = lookup)
scorepar
BiDAG:::usrDAGcorescore(y, c(x, z), n = 3, scorepar)
type <- "tree"
lookup   <- rlang:::new_environment()
scorepar <- define_scoreparameters(data, "tree", hyperpar, lookup = lookup)
BiDAG:::usrDAGcorescore(y, c(x, z), n = 3, scorepar)
scorepar <- define_scoreparameters(data, "tree", c(nlev = nlev, ess = 1, edgepf = 1), lookup = lookup)
hyperpar$edgepf <- 1
scorepar <- define_scoreparameters(data, "tree", hyperpar, lookup = lookup)
BiDAG:::usrDAGcorescore(y, c(x, z), n = 3, scorepar)
ls.str(lookup)
backdoor_params(type, data, y, x, 3, hyperpar, lookup)
params <- backdoor_params(type, x, y, z, hyperpar, NULL)
hyperpar
params <- backdoor_params(type, data, x, y, z, hyperpar, NULL)
params
lookup   <- rlang:::new_environment()
hyperpar$edgepf <- 1
scorepar <- define_scoreparameters(data, "tree", hyperpar, lookup = lookup)
BiDAG:::usrDAGcorescore(y, c(x, z), n = 3, scorepar)
ls.str(lookup)
backdoor_params(type, data, y, x, z, hyperpar, lookup)
nlev <- 2:4
lev  <- lapply(nlev-1, seq.int, from = 0)
data <- as.matrix(expand.grid(lev))
hyperpar <- list(nlev = nlev, ess = 1)
type <- "tree"
y <- 3
x <- 2
z <- 1
# no adjustment set, return params for cond distribution p(y|x)
backdoor_params("cat", data, x, y, integer(0), hyperpar, NULL)
# y is in adjustment set, return params for marginal distribution
backdoor_params("cat", data, x, y, c(y, z), hyperpar, NULL)
# with optimized partitioning
type <- "tree"
params <- backdoor_params(type, data, x, y, z, hyperpar, NULL)
# compare with results from lookup table after running BiDAG::sampleBN with user-score
lookup   <- rlang:::new_environment()
hyperpar$edgepf <- 1
scorepar <- define_scoreparameters(data, "tree", hyperpar, lookup = lookup)
BiDAG:::usrDAGcorescore(y, c(x, z), n = 3, scorepar)
ls.str(lookup)
params_lookup <- backdoor_params(type, data, y, x, z, hyperpar, lookup)
stopifnot(all.equal(params, params_lookup))
nlev <- 2:4
lev  <- lapply(nlev-1, seq.int, from = 0)
data <- as.matrix(expand.grid(lev))
y <- 3
x <- 2
z <- 1
hyperpar <- list(nlev = nlev, ess = 1)
# no adjustment set, return params for cond distribution p(y|x)
backdoor_params("cat", data, x, y, integer(0), hyperpar, NULL)
# y is in adjustment set, return params for marginal distribution
backdoor_params("cat", data, x, y, c(y, z), hyperpar, NULL)
# with optimized partitioning
type <- "tree"
params <- backdoor_params(type, data, x, y, z, hyperpar, NULL)
params
lookup   <- rlang:::new_environment()
hyperpar$edgepf <- 1
scorepar <- define_scoreparameters(data, "tree", hyperpar, lookup = lookup)
BiDAG:::usrDAGcorescore(y, c(x, z), n = 3, scorepar)
ls.str(lookup)
backdoor_params(type, data, y, x, z, hyperpar, lookup)
stopifnot(all.equal(params, params_lookup))
param$counts
params$counts
bdeu_tree <- backdoor_params(type, data, x, y, z, hyperpar, NULL)
bdeu_tree
ls.str(lookup)
lookup[["tree"]]$3.1.2
lookup[["tree"]][["3.1.2"]]
sort(x, z)
sort(c(x, z))
load_all()
type <- "tree"
bdeu_tree <- backdoor_params(type, data, x, y, z, hyperpar, NULL)
lookup   <- rlang:::new_environment()
hyperpar$edgepf <- 1
scorepar <- define_scoreparameters(data, "tree", hyperpar, lookup = lookup)
BiDAG:::usrDAGcorescore(y, c(x, z), n = 3, scorepar)
hyperpar$edgepf <- 1
scorepar <- define_scoreparameters(data, "tree", hyperpar, lookup = lookup)
BiDAG:::usrDAGcorescore(y, c(x, z), n = 3, scorepar)
ls.str(lookup)
lookup   <- rlang:::new_environment()
hyperpar$edgepf <- 1
scorepar <- define_scoreparameters(data, "tree", hyperpar, lookup = lookup)
BiDAG:::usrDAGcorescore(y, c(x, z), n = 3, scorepar)
ls.str(lookup)
load_all()
# compare with results from lookup table after running BiDAG::sampleBN with user-score
lookup   <- rlang:::new_environment()
hyperpar$edgepf <- 1
scorepar <- define_scoreparameters(data, "tree", hyperpar, lookup = lookup)
BiDAG:::usrDAGcorescore(y, c(x, z), n = 3, scorepar)
ls.str(lookup)
bdeu_lookup <- backdoor_params(type, data, y, x, z, hyperpar, lookup)
stopifnot(all.equal(bdeu, bdeu_lookup))
stopifnot(all.equal(bdeu_tree, bdeu_lookup))
bdeu_tree$counts
bdeu_lookup$counts
parentnodes <- sort.int(c(x, z), index.return = T)
parID <- paste(c(y, parentnodes$x), collapse = ".")
parID %in% names(lookup[[type]])
bdeu <- lookup[[type]][[parID]]
seq_along(parentnodes)[parentnodes$ix]
c(1, 1+seq_along(parentnodes)[parentnodes$ix])
get_dims(bdeu)
get_dim(bdeu)
aperm(bdeu, c(1, 1+seq_along(parentnodes)[parentnodes$ix]))
aperm.bida_bdeu(bdeu, c(1, 1+seq_along(parentnodes)[parentnodes$ix]))
document()
load_all()
pkgload::dev_help('backdoor_params')
aperm.bida_bdeu(bdeu, c(1, 1+seq_along(parentnodes)[parentnodes$ix]))
load_all()
aperm.bida_bdeu(bdeu, c(1, 1+seq_along(parentnodes)[parentnodes$ix]))
bdeu$dim
get_dim(bdeu)
load_all()
nlev <- 2:4
lev  <- lapply(nlev-1, seq.int, from = 0)
data <- as.matrix(expand.grid(lev))
y <- 3
x <- 2
z <- 1
hyperpar <- list(nlev = nlev, ess = 1)
# no adjustment set, return params for cond distribution p(y|x)
backdoor_params("cat", data, x, y, integer(0), hyperpar, NULL)
# y is in adjustment set, return params for marginal distribution
backdoor_params("cat", data, x, y, c(y, z), hyperpar, NULL)
# with optimized partitioning
type <- "tree"
bdeu_tree <- backdoor_params(type, data, x, y, z, hyperpar, NULL)
# compare with results from lookup table after running BiDAG::sampleBN with user-score
lookup   <- rlang:::new_environment()
hyperpar$edgepf <- 1
scorepar <- define_scoreparameters(data, "tree", hyperpar, lookup = lookup)
BiDAG:::usrDAGcorescore(y, c(x, z), n = 3, scorepar)
ls.str(lookup)
bdeu_lookup <- backdoor_params(type, data, y, x, z, hyperpar, lookup)
stopifnot(all.equal(bdeu_tree, bdeu_lookup))
bdeu_tree$counts$dim
bdeu_lookup$counts$dim
bdeu <- lookup[[type]][[parID]]
parentnodes <- sort.int(c(x, z), index.return = T)
parID <- paste(c(y, parentnodes$x), collapse = ".")
parId
parId
parID
bdeu <- lookup[[type]][[parID]]
bdeu
parentnodes[1] == x
parentnodes$x[1] == x
aperm.bida_bdeu(bdeu, c(1, 1+seq_along(parentnodes)[parentnodes$ix]))
1+seq_along(parentnodes)[parentnodes$ix]
get_dim(bdeu)
get_dim(aperm.bida_bdeu(bdeu, c(1, 1+seq_along(parentnodes)[parentnodes$ix])))
perm <- c(1, 1+seq_along(parentnodes)[parentnodes$ix])
perm
obj <- bdeu
topifnot(perm[1] == 1)
stopifnot(perm[1] == 1)
# create matrix with parent outcomes
dims_pa <- obj$counts$dim[-1]
perm_pa <- perm[-1]-1
lev_pa  <- lapply(dims_pa-1, seq.int, from = 0)
# order current parent config by permuted
conf_pa <- expand_grid_fast(lev_pa[perm_pa])
stride_pa <- c(1, cumprod(dims_pa[-length(dims_pa)]))[perm_pa]
new_indx_pa <- conf_pa%*%stride_pa
# adjust counts and partition
dims <- obj$counts$dim
dims
dims[perm]
get_dim(bdeu)
x
y
x
x
y
z
nlev[c(y, z)]
nlev[c(x, z)]
sort(c(x, z))
x
z
bdeu
bdeu_tree$counts$dim
bdeu$counts$dim
lookup[["tree"]][["3.1.2"]]
load_all()
nlev <- 2:4
lev  <- lapply(nlev-1, seq.int, from = 0)
data <- as.matrix(expand.grid(lev))
y <- 3
x <- 2
z <- 1
hyperpar <- list(nlev = nlev, ess = 1)
# no adjustment set, return params for cond distribution p(y|x)
backdoor_params("cat", data, x, y, integer(0), hyperpar, NULL)
# y is in adjustment set, return params for marginal distribution
backdoor_params("cat", data, x, y, c(y, z), hyperpar, NULL)
# with optimized partitioning
type <- "tree"
bdeu_tree <- backdoor_params(type, data, x, y, z, hyperpar, NULL)
# compare with results from lookup table after running BiDAG::sampleBN with user-score
lookup   <- rlang:::new_environment()
hyperpar$edgepf <- 1
scorepar <- define_scoreparameters(data, "tree", hyperpar, lookup = lookup)
BiDAG:::usrDAGcorescore(y, c(x, z), n = 3, scorepar)
ls.str(lookup)
bdeu_lookup <- backdoor_params(type, data, y, x, z, hyperpar, lookup)
stopifnot(all.equal(bdeu_tree, bdeu_lookup))
bdeu_tree$counts$dim
bdeu_lookup$counts$dim
parentnodes <- sort.int(c(x, z), index.return = T)
parID <- paste(c(y, parentnodes$x), collapse = ".")
parID
bdeu <- lookup[[type]][[parID]]
bdeu$counts$dim
c(1, 1+seq_along(parentnodes)[parentnodes$ix])
aperm.bida_bdeu(bdeu, c(1, 1+seq_along(parentnodes)[parentnodes$ix]))
parentnodes$x[1] == x
aperm.bida_bdeu(bdeu, c(1, 1+seq_along(parentnodes)[parentnodes$ix]))
test <- aperm.bida_bdeu(bdeu, c(1, 1+seq_along(parentnodes)[parentnodes$ix]))
all.equal(test, bdeu_tree)
test
test$counts$dim
bdeu_tree$counts$dim
all.equal(test$counts, bdeu_tree$counts)
all.equal(test, bdeu_tree)
test$partition
bdeu_tree$partition
bdeu$partition
obj <- bdeu
obj$partition)
unlist(obj$partition)
match(unlist(obj$partition), new_indx_pa)
perm
dims_pa <- obj$counts$dim[-1]
perm_pa <- perm[-1]-1
lev_pa  <- lapply(dims_pa-1, seq.int, from = 0)
# order current parent config by permuted
conf_pa <- expand_grid_fast(lev_pa[perm_pa])
stride_pa <- c(1, cumprod(dims_pa[-length(dims_pa)]))[perm_pa]
new_indx_pa <- conf_pa%*%stride_pa
match(unlist(obj$partition), new_indx_pa)-1
conf_pa
unlist(obj$partition)
bdeu_tree$partition
