score2 <- score_dag(t(dag), data, type = "categorical", params)
# test equality
expect_equal(score1, score2)
})
source("C:/Users/verak/OneDrive - Universitetet i Oslo/Documents/git/personal/bida/R/score_fam.R", echo=TRUE)
document()
optimize_partition
?switch
switch(1, invisible(pi), pi)
switch(2, invisible(pi), pi)
switch(1, invisible(pi), pi) -> test
test
for(i in c(-1:3, 9))  print(switch(i, 1, 2 , 3, 4))
params <- list()
params$partitions[[1]]
compute_freq_table
optimize_partition
table(data.frame(data))
nlev <- c(4, 1)
data <- sapply(nlev-1, sample, size = 10, replace = T)
partitions <- vector("list", length(nlev))
partitions[[2]] <- list(c(0, 1, 3), 2)
table(data.frame(data[]))
nlev <- c(4, 2)
data <- sapply(nlev-1, sample, size = 10, replace = T)
partitions <- vector("list", length(nlev))
partitions[[2]] <- list(c(0, 1, 3), 2)
table(data.frame(data[]))
nlev <- c(4, 2)
data <- sapply(nlev, sample, size = 10, replace = T)-1
partitions <- vector("list", length(nlev))
partitions[[2]] <- list(c(0, 1, 3), 2)
table(data.frame(data[]))
score_fam_cat(data, 2, 1, 1, nlev)
load_all()
rm(list = c("score_fam"))
nlev <- c(4, 2)
data <- sapply(nlev, sample, size = 10, replace = T)-1
# conditional counts of X1 given X2
table(data.frame(data))
score_fam_cat(data, 2, 1, ess = 1, nlev = nlev)
score_fam_cat(data, 2, 1, ess = 1, nlev = nlev)
nlev
j <- 2
parennodes = 1
score_fam_cat(data, 2, 1, ess = 1, nlev = nlev)
j <- 2
parentnodes <- 1
data
ess
ess <- 1
partitions = NULL
r <- nlev[j]
npar <- length(parentnodes)
if (npar == 0) {
tab <- tabulate(data[, j]+1, r)
famscore_bdeu_1row(tab, ess)
} else if (is.null(partitions) || is.null(partitions[[j]])) {
# enumerate joint outcomes
stride <- c(1, cumprod(nlev[parentnodes]))
joint  <- data[, c(parentnodes, j)]%*%stride
# compute frequency table
q   <- cp[npar+1]
tab <- matrix(tabulate(joint + 1, q*r), q, r, byrow = F)
# compute family score
famscore_bdeu(tab, ess, r, q)
} else {
# enumerate joint parent outcomes
stride <- c(1, cumprodnlev[parentnodes[-npar]])
pa     <- data[, parentnodes]%*%stride
# map to parts
parts <- get_parts(partitions[[j]])[pa+1]
# enumerate joint outcomes and compute freq table
nparts <- length(partitions[[j]])
joint  <- parts + nparts*data[, j]
tab <- matrix(tabulate(joint, nparts*r), nparts, r)
# compute family score
sum(famscore_bdeu_byrow(tab, ess, r, q, lengths(partitions[[j]])))
}
npar
is.null(partitions)
# enumerate joint outcomes
stride <- c(1, cumprod(nlev[parentnodes]))
joint  <- data[, c(parentnodes, j)]%*%stride
# compute frequency table
q   <- cp[npar+1]
tab <- matrix(tabulate(joint + 1, q*r), q, r, byrow = F)
joint
q
# compute frequency table
q   <- stride[npar+1]
tab <- matrix(tabulate(joint + 1, q*r), q, r, byrow = F)
# compute family score
famscore_bdeu(tab, ess, r, q)
load_all()
# score given partition
partitions <- vector("list", length(nlev))
partitions[[2]] <- list(c(0, 1, 3), 2)
score_fam_cat(data, 2, 1, ess = 1, nlev = nlev, partitions = partitions)
load_all()
# score given partition
partitions <- vector("list", length(nlev))
partitions[[2]] <- list(c(0, 1, 3), 2)
score_fam_cat(data, 2, 1, ess = 1, nlev = nlev, partitions = partitions)
load_all()
score_fam_cat(data, 2, 1, ess = 1, nlev = nlev)
# score given partition
partitions <- vector("list", length(nlev))
partitions[[2]] <- list(c(0, 1, 3), 2)
score_fam_cat(data, 2, 1, ess = 1, nlev = nlev, partitions = partitions)
ldags:::get_parts()
ldags:::get_parts
?ldags:::get_parts
load_all()
document()
pkgload::dev_help('get_parts')
document()
pkgload::dev_help('get_parts')
levels <- list(0:1, 0:2)
conf <- expand.grid(levels)
# enumerate joint outcomes
nlev <- lengths(levels)
stride <- c(1, cumprod(nlev[-length(nlev)]))
joint <- conf%*%stride
nlev <- lengths(levels)
conf
stride
levels <- list(0:1, 0:2)
conf <- expand.grid(levels)
stride <- c(1, cumprod(nlev[-length(nlev)]))
nlev <- lengths(levels)
stride <- c(1, cumprod(nlev[-length(nlev)]))
joint <- conf%*%stride
joint <- conf%*%stride
conf
document()
# list all configurations of two categorical variables
levels <- list(0:1, 0:2)
conf <- expand.grid(levels)
# enumerate joint outcomes
nlev <- lengths(levels)
stride <- c(1, cumprod(nlev[-length(nlev)]))
joint <- as.matrix(conf)%*%stride
# define partition over
P <- list(c(0, 1, 3), 2, 4, 5)
cbind(conf, joint, get_parts(P))
joint <- as.matrix(conf)%*%stride
P <- list(c(0, 1, 3, 5), 2, 4)
cbind(conf, joint, get_parts(P))
document()
pkgload::dev_help('score_fam')
# test equality
expect_equal(score_dag(dag, data, type = "cat", params))
score_dag
score_fam
test <- "cat"
switch(test, "cat" = TRUE, "test" = 3)
switch("categorical", "cat" = TRUE, "test" = 3)
switch("categorical", "cat" = TRUE, FALSE)
switch("cat", "categorical" = TRUE, FALSE)
load_all()
dag1 <- rbind(z = c(0, 1, 1),
x = c(0, 0, 1),
y = c(0, 0, 0))
dag2 <- rbind(z = c(0, 0, 1),
x = c(0, 1, 1),
y = c(0, 0, 0))
params <- list(ess = 1,
nlev = c(2, 2, 2),
partitions = list(NULL, NULL, c(0:2, 3)))
# test equality
expect_equal(score_dag(dag1, data, type = "cat", params),
score_dag(dag2, data, type = "cat", params),
)
data <- sapply(nlev, sample, size = 100, replace = T) -1
data
test_that("score equivalence of bdeu score", {
dag <- rbind(c(0, 1, 0, 0),
c(0, 0, 1, 0),
c(0, 0, 0, 1),
c(0, 0, 0, 0))
#'
# Rgraphviz::plot(as(dag, "graphNEL"))
# Rgraphviz::plot(as(t(dag), "graphNEL"))
n <- ncol(dag)
params <- list(nlev = 1:n + 1, ess = 1)
data <- sapply(params$nlev, sample, size = 10, replace = T) - 1
# compute score of both DAGs in Markov equiv class
score1 <- score_dag(dag, data, type = "categorical", params)
score2 <- score_dag(t(dag), data, type = "categorical", params)
# test equality
expect_equal(score1, score2)
})
# test score equivalence
data <- sapply(nlev, sample, size = 100, replace = T)-1
expect_equal(score_dag(dag1, data, type = "cat", params),
score_dag(dag2, data, type = "cat", params),
)
data
# test score equivalence
data <- sapply(params$nlev, sample, size = 100, replace = T)-1
expect_equal(score_dag(dag1, data, type = "cat", params),
score_dag(dag2, data, type = "cat", params),
)
expect_equal(score_dag(dag1, data, type = "cat", params),
score_dag(dag2, data, type = "cat", params))
score_fam_cat(data, 3, 1:2, 1, params$nlev, params$partitions)
j <- 3
parentnodes <- 1:2
ess = 1
nlev = params$nlev
partitions = params$partitions
r <- nlev[j]
npar <- length(parentnodes)
if (npar == 0) {
tab <- tabulate(data[, j]+1, r)
famscore_bdeu_1row(tab, ess)
} else if (is.null(partitions) || is.null(partitions[[j]])) {
# enumerate joint outcomes
stride <- c(1, cumprod(nlev[parentnodes]))
joint  <- data[, c(parentnodes, j), drop = FALSE]%*%stride
# compute frequency table
q   <- stride[npar+1]
tab <- matrix(tabulate(joint + 1, q*r), q, r, byrow = F)
# compute family score
famscore_bdeu(tab, ess, r, q)
} else {
# enumerate joint parent outcomes
stride <- c(1, cumprod(nlev[parentnodes[-npar]]))
pa     <- data[, parentnodes, drop = FALSE]%*%stride
# map to parts
parts <- get_parts(partitions[[j]])[pa+1]
# enumerate joint outcomes and compute freq table
nparts <- length(partitions[[j]])
joint  <- parts + nparts*data[, j]
tab <- matrix(tabulate(joint, nparts*r), nparts, r)
# compute family score
sum(famscore_bdeu_byrow(tab, ess, r, q, lengths(partitions[[j]])))
}
load_all()
score_fam(data, 3, parentnodes = 1:2, "cat", params)
score_fam(data, 3, parentnodes = 1:2, "cat", params)
j
parentnodes
r
q
load_all()
score_fam(data, 3, parentnodes = 1:2, "cat", params)
score_fam(data, 3, parentnodes = 1:2, "cat", params)
tab
ess
r
q
load_all()
params <- list(ess = 1,
nlev = c(2, 2, 2),
partitions = list(NULL, NULL, c(0:2, 3)))
# test score equivalence
data <- sapply(params$nlev, sample, size = 100, replace = T)-1
expect_equal(score_dag(dag1, data, type = "cat", params),
score_dag(dag2, data, type = "cat", params))
expect_equal(score_dag(dag1, data, type = "cat", params[-3]),
score_dag(dag2, data, type = "cat", params[-3]))
famscore_bdeu_byrow
partitions
test_that("score equivalence of bdeu score", {
dag <- rbind(c(0, 1, 0, 0),
c(0, 0, 1, 0),
c(0, 0, 0, 1),
c(0, 0, 0, 0))
#'
# Rgraphviz::plot(as(dag, "graphNEL"))
# Rgraphviz::plot(as(t(dag), "graphNEL"))
n <- ncol(dag)
params <- list(nlev = 1:n + 1, ess = 1)
data <- sapply(params$nlev, sample, size = 10, replace = T) - 1
# compute score of both DAGs in Markov equiv class
score1 <- score_dag(dag, data, type = "categorical", params)
score2 <- score_dag(t(dag), data, type = "categorical", params)
# test equality
expect_equal(score1, score2)
})
test_that("score equivalence of bdeu score", {
dag <- rbind(c(0, 1, 0, 0),
c(0, 0, 1, 0),
c(0, 0, 0, 1),
c(0, 0, 0, 0))
#'
# Rgraphviz::plot(as(dag, "graphNEL"))
# Rgraphviz::plot(as(t(dag), "graphNEL"))
n <- ncol(dag)
params <- list(nlev = 1:n + 1, ess = 1)
data <- sapply(params$nlev, sample, size = 10, replace = T) - 1
# compute score of both DAGs in Markov equiv class
score1 <- score_dag(dag, data, type = "categorical", params)
score2 <- score_dag(t(dag), data, type = "categorical", params)
# test equality
expect_equal(score1, score2)
})
dag <- rbind(c(0, 1, 0, 0),
c(0, 0, 1, 0),
c(0, 0, 0, 1),
c(0, 0, 0, 0))
#'
# Rgraphviz::plot(as(dag, "graphNEL"))
# Rgraphviz::plot(as(t(dag), "graphNEL"))
n <- ncol(dag)
params <- list(nlev = 1:n + 1, ess = 1)
data <- sapply(params$nlev, sample, size = 10, replace = T) - 1
# compute score of both DAGs in Markov equiv class
score1 <- score_dag(dag, data, type = "categorical", params)
dag <- rbind(c(0, 1, 0, 0),
c(0, 0, 1, 0),
c(0, 0, 0, 1),
c(0, 0, 0, 0))
#'
# Rgraphviz::plot(as(dag, "graphNEL"))
# Rgraphviz::plot(as(t(dag), "graphNEL"))
n <- ncol(dag)
params <- list(nlev = 1:n + 1, ess = 1)
data <- sapply(params$nlev, sample, size = 10, replace = T) - 1
# compute score of both DAGs in Markov equiv class
score1 <- score_dag(dag, data, type = "categorical", params)
famscore_bdeu_byrow
dag <- rbind(c(0, 1, 0, 0),
c(0, 0, 1, 0),
c(0, 0, 0, 1),
c(0, 0, 0, 0))
#'
# Rgraphviz::plot(as(dag, "graphNEL"))
# Rgraphviz::plot(as(t(dag), "graphNEL"))
n <- ncol(dag)
params <- list(nlev = 1:n + 1, ess = 1)
data <- sapply(params$nlev, sample, size = 10, replace = T) - 1
# compute score of both DAGs in Markov equiv class
score1 <- score_dag(dag, data, type = "categorical", params)
test_that("score equivalence of bdeu score", {
dag <- rbind(c(0, 1, 0, 0),
c(0, 0, 1, 0),
c(0, 0, 0, 1),
c(0, 0, 0, 0))
#'
# Rgraphviz::plot(as(dag, "graphNEL"))
# Rgraphviz::plot(as(t(dag), "graphNEL"))
n <- ncol(dag)
params <- list(nlev = 1:n + 1, ess = 1)
data <- sapply(params$nlev, sample, size = 10, replace = T) - 1
# compute score of both DAGs in Markov equiv class
score1 <- score_dag(dag, data, type = "cat", params)
score2 <- score_dag(t(dag), data, type = "cat", params)
# test equality
expect_equal(score1, score2)
})
dag1 <- rbind(z = c(0, 1, 1),
x = c(0, 0, 1),
y = c(0, 0, 0))
dag2 <- rbind(z = c(0, 0, 1),
x = c(0, 1, 1),
y = c(0, 0, 0))
params <- list(ess = 1,
nlev = c(2, 2, 2),
partitions = list(NULL, NULL, c(0:2, 3)))
# test score equivalence
data <- sapply(params$nlev, sample, size = 100, replace = T)-1
expect_equal(score_dag(dag1, data, type = "cat", params[-3]),
score_dag(dag2, data, type = "cat", params[-3]))
dag1
dag2
dag2 <- rbind(z = c(0, 0, 1),
x = c(1, 0, 1),
y = c(0, 0, 0))
params <- list(ess = 1,
nlev = c(2, 2, 2),
partitions = list(NULL, NULL, c(0:2, 3)))
# test score equivalence
data <- sapply(params$nlev, sample, size = 100, replace = T)-1
expect_equal(score_dag(dag1, data, type = "cat", params[-3]),
score_dag(dag2, data, type = "cat", params[-3]))
expect_equal(score_dag(dag1, data, type = "cat", params),
score_dag(dag2, data, type = "cat", params))
expect_equal(score_dag(dag1, data, type = "cat", params),
score_dag(dag2, data, type = "cat", params))
expect_equal(score_dag(dag1, data, type = "cat", params),
score_dag(dag3, data, type = "cat", params))
dag
score_dag(dag, data, type = "cat", params)
n   <- 3
dag <- matrix(0, n, n)
dag[upper.tri(dag)] <- 1
# categorical
N <- 100
params <- list(nlev = rep(3, n), ess = 1)
data <- sapply(params$nlev, sample, size = N, replace = T) -1
score <- score_dag(dag, data, type = "cat", params)
score == score_dag(t(dag), data, type = "cat", params) # score equiv
# labeled DAG - add list of partitions of each CPT
params$partition <- list(NULL, NULL, list(c(0, 1), 2, 3))
score_dag(dag, data, type = "cat", params)
score
0:4%%2
0:4%/%2
rgamma(100, 1/1000)
sum(rgamma(100, 1/1000))
rDirichlet(1, rep(1/1000, 1000))
0_3%%2
0:3%%2
0:3%/%2
matrix(1:2, 1, 2)
t(matrix(1:2, 1, 2))
library(devtools)
load_all()
load_all()
knitr::opts_chunk$set(echo = TRUE,
results = "hold")
library(pcalg) # for as(adjmat, "graphNEL")
library(ldags)
here::i_am("./inst/vignettes/optimize_partition.Rmd")
getwd()
library(pcalg) # for as(adjmat, "graphNEL")
library(ldags)
here::i_am("./inst/vignettes/optimize_partition.Rmd")
knitr::opts_chunk$set(echo = TRUE,
results = "hold")
library(pcalg) # for as(adjmat, "graphNEL")
library(ldags)
here::i_am("./inst/vignettes/optimize_partition.Rmd")
tester <- function(counts, levels, methods = c("tree", "ldag", "part"), regular = F) {
df <- cbind(expand.grid(levels), n = counts)
scores <- setNames(numeric(length(methods)), methods)
for (method in methods) {
res <- optimize_partition(counts, levels, ess = 1, method, regular = regular)
df[[method]] <- get_parts(res$partition)
scores[method] <- sum(res$scores)
}
df[["none"]] <- seq_len(nrow(counts))
scores["none"] <- sum(ldags:::compute_local_bdeu_score_from_counts(counts, 1, ncol(counts), nrow(counts), s = 1))
return(list(df, scores))
}
levels <- rep(list(0:1), 2)
counts <- cbind(10, c(10, 10, 100, 100))
tester(counts, levels)
cat("Score, P(Y|X1, X2):")
bida:::famscore_bdeu(counts, ess = 1, r = 2, q = 4, s = 1)
bida:::famscore_bdeu_byrow(counts, ess = 1, r = 2, q = 4, s = 1)
cat("Score, P(Y|X1, X2):")
sum(bida:::famscore_bdeu_byrow(counts, ess = 1, r = 2, q = 4, s = 1))
cat("Score, P(Y|X2):")
sum(bida:::famscore_bdeu_byrow(rowsum(counts, c(1, 1, 2, 2)), ess = 1, r = 2, q = 4, s = c(2, 2)))
cat("Score P(Y):")
sum(bida:::famscore_bdeu_byrow(matrix(colSums(counts), 1), ess = 1, r = 2, q = 4, s = 4))
tester(counts, levels, regular = T)
tester <- function(counts, levels, methods = c("tree", "ldag", "part"), regular = F) {
df <- cbind(expand.grid(levels), n = counts)
scores <- setNames(numeric(length(methods)), methods)
for (method in methods) {
res <- optimize_partition(counts, levels, ess = 1, method, regular = regular)
df[[method]] <- get_parts(res$partition)
scores[method] <- sum(res$scores)
}
df[["none"]] <- seq_len(nrow(counts))
scores["none"] <- sum(bida:::famscore_bdeu_byrow(counts, 1, ncol(counts), nrow(counts), s = 1))
return(list(df, scores))
}
levels <- rep(list(0:1), 2)
counts <- cbind(10, c(10, 10, 100, 100))
tester(counts, levels)
tester(counts, levels, regular = T)
levels <- rep(list(0:1), 4)
nlev <- lengths(levels)
ess <- 1
for (i in 1:100) {
#cat("\niter:", i, "\n")
counts <- matrix(rgamma(2**(length(levels)+1), shape = 1), ncol = 2)
fits <- list()
fits$part <- optimize_partition(counts, levels, ess, "part", regular = T, F)
fits$ldag <- optimize_partition(counts, levels, ess, "ldag", regular = T, F)
partitions <- sapply(lapply(fits, "[[", "partition"), get_parts)
# stop and print output if part and ldag do not coincide
if (!all(partitions[, "part"] == partitions[, "ldag"])) {
cbind(expand.grid(levels), partitions)
cat("\npart:")
fits$part <- optimize_partition(counts, levels, ess, "part", regular = T, T)
cat("\nldag:")
fits$ldag <- optimize_partition(counts, levels, ess, "ldag", regular = T, T)
is_CSI_consistent(fits$part$partition, nlev)
is_regular(fits$part$partition, nlev)
is_CSI_consistent(fits$ldag$partition, nlev)
is_regular(fits$ldag$partition, nlev)
break
}
}
bn   <- readRDS(here::here("./data/LDAG10.rds"))
bn   <- readRDS(here::here("./data/LDAG10.rds"))
dag  <- bnlearn::amat(bn)
nlev <- rep(2, 10)
levels <- lapply(nlev-1, seq.int, from = 0)
bn
# Load
devtools::install_github("verahk/bida", ref = "dev")
remove.packages("bida")
# Load
devtools::install_github("verahk/bida", ref = "dev")
# load libraries ----
devtools::install_github("verahk/bida",
ref = "backdoor_estimates_with_local_structure")
# load libraries ----
devtools::install_github("verahk/bida",
ref = "sim_backdoor_estimates_with_local_structure")
devtools:::document()
# load libraries ----
devtools::install_github("verahk/bida",
ref = "sim_backdoor_estimates_with_local_structure")
