# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @rdname factor_product_c
combine_char_vectors_c <- function(x, y) {
    .Call(`_bida_combine_char_vectors_c`, x, y)
}

#' @rdname factor_product_c
named_array_c <- function(values, dim, names) {
    .Call(`_bida_named_array_c`, values, dim, names)
}

#' @rdname factor_product_c
scope_c <- function(x) {
    .Call(`_bida_scope_c`, x)
}

stride_c <- function(x) {
    .Call(`_bida_stride_c`, x)
}

#' Compute product of two factors
#'
#' @param x,y numeric vectors with:
#' - dimensions/cardinalities given by `x.attr("dim")` and similarly for `y`
#' - scope given by names of `x.attr("dimnames")` and similarly for `y`
#' @seealso cpqueries_from_cpt_arrays
#' @keywords internal
#'
factor_product_c <- function(x, y) {
    .Call(`_bida_factor_product_c`, x, y)
}

#' @rdname factor_product_c
factors_product_c <- function(factors) {
    .Call(`_bida_factors_product_c`, factors)
}

#' Identify valid adjustment sets
#'
#' Given the set of ancestors A of X and Y and a valid adjustment set
#' \eqn{Z \subseteq A \setminus Desc(X)}, find the subset of Z nearest X (or Y)
#' that is valid for adjustment.
#' @name find_nearest_adjset
#' @details
#' Based on Zander and LiÅ›kiewicz (2020), with a modified Algorithm 3.1 in Koller (2009, p. 75)
#' for finding reachable nodes.
#' Can be used to find:
#' - O-set: the subset closest to Y.
#' - Parent sets: the subset closets to X.
#' - Minimal o-set: the subset of the O-set closest to Y,
#'   i.e. the subset of nodes that can be reached from both X and Y.
#' - Minimal parent set: the subset of parents of X closets to Y,
#'   i.e. the subset of parents that can be reached from both X and Y.
#' @param G a n-by-n adjacency matrix of a backdoor graph. \code{G[i, j] = 1} if there is a path from node i to node j, zero otherwise.
#' @param dmat a  n-by-n adjacency matrix of ancestor relations.
#'   If  \code{dmat[i, j] = 1} `i' is an ancestor of `j' in the original graph.
#'   Used to check if traversed nodes are ancestors of `Z` looking for v-structures.
#' @param X (integer)
#'   column position of source variable (using C++ indexing, from 0 to n-1)
#' @param A (logical vector)
#'   indicates the set of nodes trails must be in.
#'   The search along a path ends if visiting a node i such that `A[i] = FALSE`.
#' @param Z (integer vector)
#'    column positions of conditioning variables (using C++ indexing, from 0 to n-1)
#' @return
#' - `find_nodes_reachable_via_ancestor` implements Algorithm 3.1 in Koller (2009, p. 75)
#' for finding nodes reachable from `X` given `Z` via active trails in `G, with the restriction
#' that only trails where all nodes are in A is considered. On such paths there
#' can not be any colliders, so this implementation includes no check for colliders
#' in Z.
#' - `find_nearest_adjset` return the subset of Z that is reachable from X.
#' @example man/examples/find_nearest_adjset.R
find_nodes_reachable_via_ancestors <- function(G, dmat, X, A, Z = 0L) {
    .Call(`_bida_find_nodes_reachable_via_ancestors`, G, dmat, X, A, Z)
}

#' @rdname find_nearest_adjset
#' @export
find_nearest_adjset <- function(G, dmat, X, A, Z) {
    .Call(`_bida_find_nearest_adjset`, G, dmat, X, A, Z)
}

