---
title: "Test of local structure optimization routines"
author: "Vera Kvisgaard"
date: "2024-05-22"
output: html_document
---

This notes illustrates the usage of the `optimize_partition` routines for learning a partitioning of a CPT from data,
and is intended to evaluate that these routines behave as expected.


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      results = "hold")
```

```{r, results = "hide"}
library(bida)
library(ggplot2)
here::i_am("./inst/rmd/optimize_partition.Rmd")
```

# Basic usage
The documentation of the function is found running `?bida::optimize_partition`.
Here follows a few examples. 
### Binary split
First, design a frequency table `counts` representing a binary split and compare the output from the three optimization algorithms `tree`, `ldag` and `part`.
```{r}
levels <- rep(list(0:1), 2)
counts <- cbind(10, c(10, 10, 100, 100))
fits <- list() 

# optimize partition over rows in the frequency table
fits$tree <- optimize_partition(counts, levels, ess = 1, "tree", regular = F, verbose = T) 
fits$ldag <- optimize_partition(counts, levels, ess = 1, "ldag", regular = F, verbose = T) 
fits$part <- optimize_partition(counts, levels, ess = 1, "part", regular = F, verbose = T) 
```

```{r}
# compare counts and optimized partitions
parts  <- sapply(fits, function(x) get_parts(x$partition))
cbind(expand.grid(levels), counts, parts)

# print scores
sapply(fits, function(x) sum(x$scores))
```

The `regular = TRUE` option of the `optimize_partition` function forces a partition that do not implicitly encode any conditional independencies.
```{r}
fits <- list()
fits$tree <- optimize_partition(counts, levels, ess = 1, "tree", regular = T, verbose = F) 
fits$ldag <- optimize_partition(counts, levels, ess = 1, "ldag", regular = T, verbose = F) 
fits$part <- optimize_partition(counts, levels, ess = 1, "part", regular = T, verbose = F) 

# compare counts and optimized partitions
parts  <- sapply(fits, function(x) get_parts(x$partition))
cbind(expand.grid(levels), counts, parts)

# print scores
sapply(fits, function(x) sum(x$scores))
```

### V-structure
While both the `tree` and `ldag` procedures can learn binary splits, `tree` can not learn v-structures.
```{r}
counts <- cbind(c(100, 10, 10, 10), c(10, 100, 100, 100))

# optimize partition over rows in the frequency table
fits <- list()
fits$tree <- optimize_partition(counts, levels, ess = 1, "tree", regular = F, verbose = F) 
fits$ldag <- optimize_partition(counts, levels, ess = 1, "ldag", regular = F, verbose = F) 
fits$part <- optimize_partition(counts, levels, ess = 1, "part", regular = F, verbose = F) 

# compare counts and optimized partitions
parts  <- sapply(fits, function(x) get_parts(x$partition))
cbind(expand.grid(levels), counts, parts)

# print scores
sapply(fits, function(x) sum(x$scores))
```


## Mixed cardinality
```{r}
levels <- list(0:1, 0:2)
counts <- cbind(1, rep(c(10, 100, 1000), each = 2))

# optimize partition over rows in the frequency table
fits <- list()
fits$tree <- optimize_partition(counts, levels, ess = 1, "tree", regular = F, verbose = T) 
fits$ldag <- optimize_partition(counts, levels, ess = 1, "ldag", regular = F, verbose = T) 
#fits$part <- optimize_partition(counts, levels, ess = 1, "part", regular = F, verbose = F) 

# compare counts and optimized partitions
parts  <- sapply(fits, function(x) get_parts(x$partition))
cbind(expand.grid(levels), counts, parts)

# print scores
sapply(fits, function(x) sum(x$scores))
```

# Large sample size behaviour
This simulation experiment studies the large sample size behaviour of the optimization routines.
Given a true partition `parts` of a parent space, the following code block implements the following simulation scheme: 

1. Sample a CPT consistent with the partition `parts` 
2. For each sample size, sample the outcome variable from that CPT. The parent outcomes are assumed uniformily distributed. 
3. Learn a partition from the data and compare with the true partition. A paired-confusion matrix is used to evaluate the learned and true partition. 
```{r}


run <- function(parts, levels, r, alpha = rep(1, r), verbose = F, doPlot = T) {
  # simulation: learn partitions from data 
  # 1. for each rep, draw a reduced CPT over parts 
  # 2. for each sample size, simulate data from the CPT
  #    - infer a partition from data 
  #    - evaluate the partition by the pair-confusion-matrix
  
  tmp <- unique(parts)
  nparts <- length(tmp)
  parts  <- match(parts, tmp) # relab parts from 1, 2, .., nparts
  q <- length(parts)
  
  # init array for storing results 
  simpar <- list(rep = 1:5,
                 N = round(10**seq(2, 4, length.out = 11)), 
                 struct = c("tree", "ldag"),
                 regular = c(TRUE, FALSE))
  res <- array(list(), lengths(simpar), simpar)
 
  
  for (i in simpar$rep) {
    
    # draw reduced CPT
    set.seed(i)
    cpt <- vapply(1:nparts, function(x) bida:::rDirichlet(1, alpha), numeric(r))
    
    for (j in seq_along(simpar$N)) {
      
      N <- simpar$N[[j]]
      
      
      # sample from conditional distribution
      set.seed(j)
      par <- sample.int(q, N, replace = T) # sample parents uniformily
      x   <- bida:::sample_from_cpt(cpt, parts[par]-1, r)
      # check means
      tab <- table(parts[par], x)
      tab/rowSums(tab)-t(cpt)
      
      
      # compute frequency table 
      tab  <- as.matrix(table(par, x))
     
      for (k in seq_along(simpar$struct)) {
        for (l in seq_along(simpar$regular)){
          struct <- simpar$struct[k]
          regular <- simpar$regular[l]
          if (verbose) cat("\nOptimize.", N, struct, regular)
          # optimize local structure 
          fit <- bida:::optimize_partition(tab, levels, 1, struct, regular = regular, verbose = verbose)
          
          # compute partition similarity
          tmp <- get_parts(fit$partition)
          res[[i, j, k, l]] <- compute_paired_confusion_matrix(tmp, parts)
          
          # compute MSE of point-estimates
          
        }
      }
    }
  }
  
  df <- cbind(expand.grid(simpar), do.call(rbind, res))
  plots <- list()
    
  if (doPlot) {
    # F-measure
    plot <- ggplot(df, aes(N, y = 2*a/(2*a+b+c),  group = rep)) +
                  facet_grid(. ~ struct + regular) +
                  geom_line() +
                  scale_x_log10()
    plots$Fmeasure <- plot
    
    # decomp paired comparisons
    df_long <- tidyr::pivot_longer(df, letters[1:4])
    plot <- ggplot(df_long, aes(N, value, fill = name)) +
              facet_grid(rep ~ struct + regular) +
              geom_col() +
              scale_x_log10()
    plots$compar <- plot

  }
  return(list(df = df, plots = plots))
}


compute_paired_confusion_matrix <- function(x, y) {
  stopifnot(length(x) == length(y))
  n <- length(x) 
  res <- matrix(NA, n, n)
  for (i in seq(n)[-n]) {
    for (j in seq(i+1, n)) {
      #cat("\n", i, j, x[i], x[j], y[i], y[j])
      if (x[i] == x[j]) {
        if (y[i] == y[j]) {
          res[i, j] <- "a"
        } else {
          res[i, j] <- "b"
        }
      } else if (y[i] == y[j]) {
        res[i, j] <- "c"
      } else {
        res[i, j] <- "d"
      }
    }
  }
  table(factor(res, letters[1:4]))
}


```


## Binary split over two binary parents
```{r}
levels <- list(0:1, 0:1)
labels <- list(rbind(0), NULL)
parts  <- bida:::labels_to_parts(labels, lengths(levels), levels)

# print partition
cbind(expand.grid(levels), parts)

# run simulation
res <- run(parts, levels, r = 2, verbose = F)
res$plots$compar
res$plots$Fmeasure
```

## Vstructure over two binary parents
```{r}
levels <- list(0:1, 0:1)
labels <- list(rbind(0), rbind(0))
parts  <- bida:::labels_to_parts(labels, lengths(levels), levels)

# print partition
cbind(expand.grid(levels), parts)

# run simulation
res <- run(parts, levels, r = 2, verbose = F)
res$plots$compar
```

## Three binary parents
```{r}
levels <- list(0:1, 0:1, 0:1)
labels <- list(rbind(c(0, 0), c(1, 0)), 
               rbind(c(0, 0), c(1, 0)), 
               NULL)
parts  <- bida:::labels_to_parts(labels, lengths(levels), levels)

# print partition
cbind(expand.grid(levels), parts)

# run simulation
res <- run(parts, levels, r = 2, verbose = F)
res$plots$compar
```

## Mixed cardinality
```{r}
levels <- list(0:1, 0:2, 0:3)
labels <- list(NULL,
               rbind(c(0, 0), c(1, 0)), 
               rbind(c(0, 0), c(1, 0)))
parts  <- bida:::labels_to_parts(labels, lengths(levels), levels)

# print partition
cbind(expand.grid(levels), parts)

# run simulation
res <- run(parts, levels, r = 3, verbose = F)
res$plots$compar
```
