---
title: "Test of local structure optimization routines"
author: "Vera Kvisgaard"
date: "2024-05-22"
output: html_document
---

This notes illustrates the usage of the `optimize_partition` routines for learning a partitioning of a CPT from data,
and is intended to evaluate that these routines behave as expected.


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      results = "hold")
```

```{r, results = "hide"}
library(bida)
library(ggplot2)
here::i_am("./inst/rmd/optimize_partition.Rmd")
```

# Basic usage
The documentation of the function is found running `?bida::optimize_partition`.
Here follows a few examples, where the optimization algorithms are applied to counts from a binary split, a v-structure and mixed cardinality setting.

### Binary split
First, design a frequency table `counts` representing a binary split and compare the output from the three optimization algorithms `tree`, `ldag` and `part`.
```{r}
levels <- rep(list(0:1), 2)
counts <- cbind(10, c(10, 10, 100, 100))
fits <- list() 

# optimize partition over rows in the frequency table
fits$tree <- optimize_partition(counts, levels, ess = 1, "tree", regular = F, verbose = T) 
fits$ldag <- optimize_partition(counts, levels, ess = 1, "ldag", regular = F, verbose = T) 
fits$part <- optimize_partition(counts, levels, ess = 1, "part", regular = F, verbose = T) 
```

```{r}
# compare counts and optimized partitions
parts  <- sapply(fits, function(x) get_parts(x$partition))
cbind(expand.grid(levels), counts, parts)

# print scores
sapply(fits, function(x) sum(x$scores))
```

The `regular = TRUE` option of the `optimize_partition` function forces a partition that do not implicitly encode any conditional independencies.
```{r}
fits <- list()
fits$tree <- optimize_partition(counts, levels, ess = 1, "tree", regular = T, verbose = F) 
fits$ldag <- optimize_partition(counts, levels, ess = 1, "ldag", regular = T, verbose = F) 
fits$part <- optimize_partition(counts, levels, ess = 1, "part", regular = T, verbose = F) 

# compare counts and optimized partitions
parts  <- sapply(fits, function(x) get_parts(x$partition))
cbind(expand.grid(levels), counts, parts)

# print scores
sapply(fits, function(x) sum(x$scores))
```

### V-structure
While both the `tree` and `ldag` procedures can learn binary splits, `tree` can not learn v-structures.
```{r}
counts <- cbind(c(100, 10, 10, 10), c(10, 100, 100, 100))

# optimize partition over rows in the frequency table
fits <- list()
fits$tree <- optimize_partition(counts, levels, ess = 1, "tree", regular = F, verbose = F) 
fits$ldag <- optimize_partition(counts, levels, ess = 1, "ldag", regular = F, verbose = F) 
fits$part <- optimize_partition(counts, levels, ess = 1, "part", regular = F, verbose = F) 

# compare counts and optimized partitions
parts  <- sapply(fits, function(x) get_parts(x$partition))
cbind(expand.grid(levels), counts, parts)

# print scores
sapply(fits, function(x) sum(x$scores))
```


## Mixed cardinality
```{r}
levels <- list(0:1, 0:2)
counts <- cbind(1, rep(c(10, 100, 1000), each = 2))

# optimize partition over rows in the frequency table
fits <- list()
fits$tree <- optimize_partition(counts, levels, ess = 1, "tree", regular = F, verbose = T) 
fits$ldag <- optimize_partition(counts, levels, ess = 1, "ldag", regular = F, verbose = T) 
#fits$part <- optimize_partition(counts, levels, ess = 1, "part", regular = F, verbose = F) 

# compare counts and optimized partitions
parts  <- sapply(fits, function(x) get_parts(x$partition))
cbind(expand.grid(levels), counts, parts)

# print scores
sapply(fits, function(x) sum(x$scores))
```

# Large sample size behaviour
This simulation experiment studies the large sample size behaviour of the optimization routines.
Given a true partition `parts` of a parent space, the following code block implements the following simulation scheme: 

1. Sample a CPT consistent with the partition `parts` 
2. For each sample size, sample the outcome variable from that CPT. The parent outcomes are assumed uniformily distributed. 
3. Learn a partition from the data and compare with the true partition. A paired-confusion matrix is used to evaluate the learned and true partition. 
```{r}


run <- function(parts, levels, r, reps = 10, alpha = rep(1, r), verbose = F, doPlot = T) {
  # simulation: learn partitions from data 
  # parts = partitioning of parent space
  # levels = levels of the parent variables
  # r: cardinality of outcome variable
  # alpha: hyperparam for Dirichlet distrib over each conditional prob vector 
  
  # relab parts from 1, 2, .., nparts
  uparts <- unique(parts)
  nparts <- length(uparts)
  parts  <- match(parts, uparts) 
  q <- length(parts)
  
  # specify simparams and init array for storing results 
  simpar <- list(rep = 1:reps,
                 N = round(10**seq(2, 4, length.out = 11)), 
                 struct = c("tree", "ldag"),
                 regular = c(TRUE, FALSE))
  res <- array(list(), lengths(simpar), simpar)
 
  for (i in simpar$rep) { 
    
    # draw reduced CPT
    set.seed(i)
    cpt <- vapply(1:nparts, function(x) bida:::rDirichlet(1, alpha), numeric(r))
    tcpt <- t(cpt)
    
    for (j in seq_along(simpar$N)) {
      
      N <- simpar$N[[j]]
      
      
      # sample from conditional distribution
      set.seed(j)
      par <- sample.int(q, N, replace = T) # sample parents uniformily
      x   <- bida:::sample_from_cpt(t(cpt), parts[par], r)
      
      # compute frequency table 
      tab  <- as.matrix(table(par, x))
      
      # compute squared errors of point-estimates 
      ess  <- 1
      tmp  <- tab + ess/(q*r)
      sqerr <- sum((tmp/rowSums(tmp)-tcpt[parts, ])**2)
      
      for (k in seq_along(simpar$struct)) {
        for (l in seq_along(simpar$regular)){
          struct <- simpar$struct[k]
          regular <- simpar$regular[l]
          if (verbose) cat("\nOptimize.", N, struct, regular)
          # optimize local structure 
          fit <- bida:::optimize_partition(tab, levels, 1, struct, regular = regular, verbose = verbose)
          
          # compute partition similarity
          opt_parts <- get_parts(fit$partition)
          res_pairs <- compute_paired_confusion_matrix(opt_parts, parts)
          
          # compute relative MSE of point-estimates
          tmp <- rowsum(tab + ess/(q*r), opt_parts)
          means <- (tmp/rowSums(tmp))[opt_parts, ]
          res_mse <- sum((means-tcpt[parts, ])**2)/sqerr
          
          res[[i, j, k, l]] <- c(res_pairs, mse = res_mse)
        }
      }
    }
  }
  
  # collect results in data.frame
  df <- cbind(expand.grid(simpar), do.call(rbind, res))
  df$Fmeasure <- with(df, 2*a/(2*a+b+c))
  plots <- list()
    
  if (doPlot) {
    # F-measure
    plot <- ggplot(df, aes(N, y = Fmeasure,  group = rep)) +
                  facet_grid(. ~ struct + regular) +
                  geom_line() +
                  #geom_violin() + 
                  scale_x_log10() +
                  geom_abline(slope = 0, intercept = 1, color = "red") +
                  coord_cartesian(ylim = c(0, 1))
    plots$Fmeasure <- plot
    
    plot <- ggplot(df, aes(N, y = mse,  group = rep)) +
                  facet_grid(. ~ struct + regular) +
                  geom_boxplot() +
                  scale_x_log10() +
                  geom_abline(slope = 0, intercept = 1, color = "red") +
                  coord_cartesian(ylim = c(0, 3))
    plots$mse <- plot
    
    # decomp paired comparisons
    df_long <- tidyr::pivot_longer(df, letters[1:4])
    plot <- ggplot(df_long, aes(N, value, fill = name)) +
              facet_grid(rep ~ struct + regular) +
              geom_col() +
              scale_x_log10()
    plots$compar <- plot

  }
  return(list(df = df, plots = plots))
}


compute_paired_confusion_matrix <- function(x, y) {
  stopifnot(length(x) == length(y))
  n <- length(x) 
  res <- matrix(NA, n, n)
  for (i in seq(n)[-n]) {
    for (j in seq(i+1, n)) {
      #cat("\n", i, j, x[i], x[j], y[i], y[j])
      if (x[i] == x[j]) {
        if (y[i] == y[j]) {
          res[i, j] <- "a"
        } else {
          res[i, j] <- "b"
        }
      } else if (y[i] == y[j]) {
        res[i, j] <- "c"
      } else {
        res[i, j] <- "d"
      }
    }
  }
  table(factor(res, letters[1:4]))
}


```


## Binary split over two binary parents
```{r, results = "hold"}
levels <- list(0:1, 0:1)
labels <- list(binary = list(rbind(0), NULL),
               vstruct = list(rbind(0), rbind(0)))

for (name in names(labels)) {
  
  cat("\nTwo binary variables, structure:", name)
  # print partition
  parts  <- bida:::partition_from_labels(labels[[name]], lengths(levels), levels)
  print(cbind(expand.grid(levels), parts))
  
  # run simulation
  res <- run(parts, levels, r = 2, verbose = F)
  lapply(res$plots, print)
}


```

## Vstructure over two binary parents
```{r}
levels <- list(0:1, 0:1)
labels <- list(rbind(0), rbind(0))
parts  <- bida:::partition_from_labels(labels, lengths(levels), levels)

# print partition
cbind(expand.grid(levels), parts)

# run simulation
res <- run(parts, levels, r = 2, verbose = F)
res <- run(parts, levels, r = 2, verbose = F)
res$plots$compar
res$plots$Fmeasure
res$plots$mse
```

## Three binary parents
```{r}
levels <- list(0:1, 0:1, 0:1)
labels <- list(rbind(c(0, 0), c(1, 0)), 
               rbind(c(0, 0), c(1, 0)), 
               NULL)
parts  <- bida:::partition_from_labels(labels, lengths(levels), levels)

# print partition
cbind(expand.grid(levels), parts)

# run simulation
res <- run(parts, levels, r = 2, verbose = F)
res$plots$compar
```

## Mixed cardinality
```{r}
levels <- list(0:1, 0:2, 0:3)
labels <- list(rbind(c(0, 0), c(1, 0)),
               rbind(c(0, 0), c(1, 0)), 
               rbind(c(0, 0), c(1, 0)))
parts  <- bida:::partition_from_labels(labels, lengths(levels), levels)

# print partition
cbind(expand.grid(levels), parts)

# run simulation
res <- run(parts, levels, r = 3, verbose = F)
res$plots$compar
```


```{r}

simpar <- list(n = 2:4,
               k = 2**seq.int(3),
               p = c(.25, .5, .75))

res <- array(list(), dim = 

               
nlev <- rep(k, n)
parts <- rand_partition(nlev, .5)
cbind(expand.grid(levels), parts)
simpar <- function(n, )
# run simulation
res <- run(parts, levels, r = 3, verbose = F)
res$plots$compar
```


