---
title: "Test LDAGs"
author: "Vera Kvisgaard"
date: "2024-08-21"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}

# fully connected graph 
n <- 3
dag <- matrix(0, n, n)
dag[upper.tri(dag)] <- 1
colnames(dag) <- rownames(dag) <- c("z", "x", "y")

nlev <- 2:4
levels <- lapply(nlev-1, seq.int, from = 0)
            
# define partition over node y
partitions <- vector("list", n)
r <- nlev[3]
q <- prod(nlev[-3])
conf <- as.matrix(expand.grid(levels[1:2]))
index <- conf%*%c(1, nlev[1])

contexts <- cbind(conf[, 2] == 0, conf[, 2] == 1)
contexts <- cbind(conf[, 1] == 0 | conf[, 2] == 0)
tmp <- apply(contexts, 2, function(x) index[x], simplify = F)
partitions[[3]] <- c(tmp, as.list(index[-(1+unlist(tmp))]))

# draw random network over labeled DAG
bn <- bida:::rand_bn(dag, "cat", alpha = 1, nlev = nlev, partitions = partitions)
bn

```

```{r}

run_optim_partition <- function(N, r, true_parts = bida:::get_parts(partitions[[3]]), verbose = F) {
  
  set.seed(r+N)
  data <- bida:::sample_data_from_bn(bn, N)
  
  j <- 3
  parentnodes <- 1:2
  r <- nlev[j]
  q <- prod(nlev[parentnodes])
  
  counts <- data[, c(parentnodes, j)]%*%c(1, cumprod(nlev[parentnodes]))
  tab    <- matrix(tabulate(counts+1, q*r), q, r)
  
  levels <- lapply(nlev[parentnodes]-1, seq.int, from = 0)
  fits <- list()
  fits$tree0 <- bida:::optimize_partition(tab, levels, 1, "tree", regular = F, verbose = verbose)
  fits$tree1 <- bida:::optimize_partition(tab, levels, 1, "tree", regular = T, verbose = verbose)
  fits$ldag0 <- bida:::optimize_partition(tab, levels, 1, "ldag", regular = F, verbose = verbose)
  fits$ldag1 <- bida:::optimize_partition(tab, levels, 1, "ldag", regular = T, verbose = verbose) 
  
  parts <- cbind(true = true_parts, 
                 vapply(fits, function(x) bida:::get_parts(x$partition), integer(q)))
  pairs <- apply(parts, 2, compute_paired_confusion_matrix, y = true_parts)
  
  return(list(fits = fits, parts = parts, pairs = pairs))
}


compute_paired_confusion_matrix <- function(x, y) {
  stopifnot(length(x) == length(y))
  n <- length(x) 
  res <- matrix(NA, n, n)
  for (i in seq(n)[-n]) {
    for (j in seq(i+1, n)) {
      if (x[i] == x[j]) {
        if (y[i] == y[j]) {
          res[i, j] <- "a"
        } else {
          res[i, j] <- "b"
        }
      } else if (y[i] == y[j]) {
        res[i, j] <- "c"
      } else {
        res[i, j] <- "d"
      }
    }
  }
  table(factor(res, letters[1:4]))
}


```

```{r}


simpar <- expand.grid(list(N = round(10**seq(2, 4, length.out = 11)), 
                           r = 1:10))
res <- mapply(run_optim_partition,
              N = simpar$N, 
              r = simpar$r, 
              SIMPLIFY = F)

tmp  <- lapply(res, "[[", "pairs")
indx <- rep.int(seq_along(tmp), sapply(tmp, nrow))
df <- data.frame(simpar[indx, ], 
                 match = rep(letters[1:4], length(tmp)),
                 do.call(rbind, tmp))
df_long <- tidyr:::pivot_longer(df, -c("N", "r", "match"))
df_wide <- tidyr::pivot_wider(df_long, names_from = "match")

library(ggplot2)
ggplot(df_long, aes(N, value,  fill = match)) +
  facet_grid(r ~ name) +
  geom_col() +
  scale_x_log10()

ggplot(df_wide, aes(N, y = 2*a/(2*a+b+c),  group = r)) +
  facet_grid(. ~ name) +
  geom_line() +
  scale_x_log10()
```



