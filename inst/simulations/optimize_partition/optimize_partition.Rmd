---
title: "Test of local structure optimization routines"
author: "Vera Kvisgaard"
date: "2024-05-22"
output:
  html_document: 
    toc: true
    toc_depth: 3
  pdf_document:
    toc: true
    toc_depth: 3
---
# Intro
This notes illustrates the usage of the `optimize_partition` routines for learning a partitioning of a CPT from data,
and is intended to evaluate that these routines behave as expected.


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      cache = TRUE,
                      results = "hold")
```

```{r, results = "hide"}
library(bida)
library(ggplot2)
here::i_am("./inst/rmd/optimize_partition.Rmd")
```

# Basic usage
The documentation of the function is found running `?bida::optimize_partition`.
Here follows a few examples, where the optimization algorithms are applied to counts from a binary split, a v-structure and mixed cardinality setting.

### Binary split
First, design a frequency table `counts` representing a binary split and compare the output from the three optimization algorithms `tree`, `ldag` and `part`.
```{r}
levels <- rep(list(0:1), 2)
counts <- cbind(10, c(10, 10, 100, 100))
fits <- list() 

# optimize partition over rows in the frequency table
fits$tree <- optimize_partition(counts, levels, ess = 1, "tree", regular = F, verbose = T) 
fits$ldag <- optimize_partition(counts, levels, ess = 1, "ldag", regular = F, verbose = T) 
fits$part <- optimize_partition(counts, levels, ess = 1, "part", regular = F, verbose = T) 
```

```{r}
# compare counts and optimized partitions
parts  <- sapply(fits, function(x) get_parts(x$partition))
cbind(expand.grid(levels), counts, parts)

# print scores
sapply(fits, function(x) sum(x$scores))
```

The `regular = TRUE` option of the `optimize_partition` function forces a partition that do not implicitly encode any conditional independencies.
```{r}
fits <- list()
fits$tree <- optimize_partition(counts, levels, ess = 1, "tree", regular = T, verbose = F) 
fits$ldag <- optimize_partition(counts, levels, ess = 1, "ldag", regular = T, verbose = F) 
fits$part <- optimize_partition(counts, levels, ess = 1, "part", regular = T, verbose = F) 

# compare counts and optimized partitions
parts  <- sapply(fits, function(x) get_parts(x$partition))
cbind(expand.grid(levels), counts, parts)

# print scores
sapply(fits, function(x) sum(x$scores))
```

### V-structure
While both the `tree` and `ldag` procedures can learn binary splits, `tree` can not learn v-structures.
```{r}
counts <- cbind(c(100, 10, 10, 10), c(10, 100, 100, 100))

# optimize partition over rows in the frequency table
fits <- list()
fits$tree <- optimize_partition(counts, levels, ess = 1, "tree", regular = F, verbose = F) 
fits$ldag <- optimize_partition(counts, levels, ess = 1, "ldag", regular = F, verbose = F) 
fits$part <- optimize_partition(counts, levels, ess = 1, "part", regular = F, verbose = F) 

# compare counts and optimized partitions
parts  <- sapply(fits, function(x) get_parts(x$partition))
cbind(expand.grid(levels), counts, parts)

# print scores
sapply(fits, function(x) sum(x$scores))
```


### Mixed cardinality
```{r}
levels <- list(0:1, 0:2)
counts <- cbind(1, rep(c(10, 100, 1000), each = 2))

# optimize partition over rows in the frequency table
fits <- list()
fits$tree <- optimize_partition(counts, levels, ess = 1, "tree", regular = F, verbose = F) 
fits$ldag <- optimize_partition(counts, levels, ess = 1, "ldag", regular = F, verbose = F) 
#fits$part <- optimize_partition(counts, levels, ess = 1, "part", regular = F, verbose = F) 

# compare counts and optimized partitions
parts  <- sapply(fits, function(x) get_parts(x$partition))
cbind(expand.grid(levels), counts, parts)

# print scores
sapply(fits, function(x) sum(x$scores))
```

\pagebreak
# Simulation: Large sample size behaviour
This simulation experiment studies the large sample size behaviour of the optimization routines.
Given a true partition `parts` of a parent space, the following code block implements the following simulation scheme: 

1. Sample a CPT consistent with the partition `parts` 
2. For each sample size, sample the outcome variable from that CPT. The parent outcomes are assumed uniformily distributed. 
3. Learn a partition from the data and compare with the true partition, with the following measures:
  - The paired-confusion matrix
  - The F-measure/DICE similarity measure for partitions. Measures the combembership of all pairs of rows in the CPT between the true and learned partition. Has a precision-like interpretation, as it measures  the number of pairs placed in the same subset in both partitions (true positives) relative to the true positives, the false positives (pairs not truly in the same subset) and the false negatives (pairs assigned to different subsets, that are truly in the same subset). Varies between 0 and 1 (perfect). Obtained from the confusion matrix (see image).
  - The squared error between the (full) true CPT and point-estimates from the partitioned CPT, measured relative to the errors of the point-estimates of the full-non-partiitoned CPT.
  

```{r run}


run <- function(parts, levels, r, reps = 10, alpha0 = rep(1, r), verbose = F, doPlot = T) {
  # simulation: learn partitions from data 
  # parts = partitioning of parent space
  # levels = levels of the parent variables
  # r: cardinality of outcome variable
  # alpha: hyperparam for Dirichlet distrib over each conditional prob vector 
  q <- length(parts)
   
  # relab parts from 1, 2, .., nparts
  uparts <- unique(parts)
  nparts <- length(uparts)
  parts  <- match(parts, uparts) 


  # specify simparams and init array for storing results 
  simpar <- list(rep = 1:reps,
                 N = round(10**seq(2, 4, length.out = 5)), 
                 struct = c("tree", "ldag"),
                 regular = c(TRUE, FALSE))
  res <- array(list(), lengths(simpar), simpar)
 
  for (i in simpar$rep) { 
    
    # draw reduced CPT
    set.seed(i)
    cpt <- vapply(1:nparts, function(x) bida:::rDirichlet(1, alpha0), numeric(r))
    tcpt <- t(cpt)
    
    for (j in seq_along(simpar$N)) {
      
      N <- simpar$N[[j]]
      
      
      # sample from conditional distribution
      set.seed(j)
      par <- sample.int(q, N, replace = T)  # sample parent uniformily
      x   <- bida:::sample_from_cpt(tcpt, parts[par], r)
      
      # compute frequency table 
      #tab  <- as.matrix(table(par, x))
      tab <- matrix(tabulate(par + q*x, q*r), q, r)
      
      # compute squared errors of point-estimates 
      ess  <- 1
      alpha <- tab + ess/(q*r)
      sqerr <- sum((alpha/rowSums(alpha)-tcpt[parts, ])**2)
      
      #profvis::profvis(bida:::optimize_partition(tab, levels, 1, "ldag", regular = T, verbose = verbose))
      
      for (k in seq_along(simpar$struct)) {
        for (l in seq_along(simpar$regular)){
          struct <- simpar$struct[k]
          regular <- simpar$regular[l]
          if (verbose) cat("\nOptimize.", N, struct, regular)
          # optimize local structure 
          fit <- bida:::optimize_partition(tab, levels, 1, struct, regular = regular, verbose = verbose)
          
          # compute partition similarity
          opt_parts <- get_parts(fit$partition)
          res_pairs <- compute_paired_confusion_matrix(opt_parts, parts)
          
          # compute relative MSE of point-estimates
          tmp <- rowsum(alpha, opt_parts)
          means <- (tmp/rowSums(tmp))[opt_parts, ]
          res_mse <- sum((means-tcpt[parts, ])**2)/sqerr
          
          res[[i, j, k, l]] <- c(res_pairs, mse = res_mse)
        }
      }
    }
  }
  
  # collect results in data.frame
  cbind(expand.grid(simpar), do.call(rbind, res))
}
```
```{r}
compute_paired_confusion_matrix <- function(x, y) {
  stopifnot(length(x) == length(y))
  n <- length(x)
  tmp <- combn(n, 2) 
  pair_x <- x[tmp[1, ]] == x[tmp[2, ]]
  pair_y <- y[tmp[1, ]] == y[tmp[2, ]]
  
  out <- tabulate(pair_x + 2*pair_y +1, 4)
  names(out) <-  c("TN", "FP", "FN", "TP")
  out
}
```

```{r plot functions, echo=FALSE}
plot_paired_comparison <- function(df, subtitle = NULL) {
   cols <-  c(TN = "grey",  FN = "blue", FP = "red",TP = "green")
   df_long <- tidyr::pivot_longer(df, names(cols))
   df_long$name <- factor(df_long$name, names(cols))
   ggplot(df_long, aes(N, value, fill = name)) +
          facet_grid(rep ~ struct + regular) +
          geom_col() +
          scale_fill_manual(values = cols) +
          scale_x_log10() +
  labs(title = "Paired comparisons", 
       subtitle = subtitle,
       caption = "Each row shows a randomly drawn CPT. \nIn a correct partition, all pairs (of rows in the CPT) is either correctly assigned to the same subset (`TP`) \nor to distinct subset (TN).") +
     theme(plot.caption = element_text(hjust = 0))
}
plot_Fmeasure <- function(df,
                          title = "F-measure",
                          subtitle = NULL, 
                          caption = NULL) {
  if (is.null(caption)) {
     caption = sprintf("The lines shows the distribution over %s runs for each sample size, with a independently drawn CPT. \nThe F-measure is 0 if no pair (of rows in the CPT) is correctly assigned to the same subset, 1 if all pairs are.", max(df$rep))
  }
  df$Fmeasure <- with(df, 2*TP/(2*TP+FP+FN))
  ggplot(df, aes(N, y = Fmeasure,  group = rep)) +
                  facet_grid(. ~ struct + regular) +
                  geom_abline(slope = 0, intercept = 1, color = "red") +
                  geom_line() +
                  #geom_violin() + 
                  scale_x_log10() +
                  coord_cartesian(ylim = c(0, 1)) +
    labs(title = title, subtitle = subtitle, caption = caption) +
     theme(plot.caption = element_text(hjust = 0))
}
plot_mse <- function(df,
                     title = "Relative MSE", 
                     subtitle = NULL,
                     caption =  sprintf("The box-plots shows the distribution over %s runs for each sample size, with a independently drawn CPT.", max(df$rep))
                    ) {
   ggplot(df, aes(N, y = mse,  group = N)) +
                  facet_grid(. ~ struct + regular) +
                  geom_abline(slope = 0, intercept = 1, color = "red") +
                  geom_boxplot() +
                  scale_x_log10() +
                  coord_cartesian(ylim = c(0, 3)) +
    labs(title = title, subtitle = subtitle, caption = caption) +
    theme(plot.caption = element_text(hjust = 0))
}
```

\pagebreak
## Simple setting
### Binary split over two binary parents
```{r}
levels <- list(0:1, 0:1)
labels <- list(rbind(0), NULL)
parts  <- bida:::partition_from_labels(labels, lengths(levels), levels)

# print partition
cbind(expand.grid(levels), parts)

# run simulation
res <- run(parts, levels, r = 2, verbose = F)
```

```{r echo=FALSE}
plot_paired_comparison(res, subtitle = "Simple setting: Binary split")
plot_mse(res, subtitle = "Simple setting: Binary split")
```

\pagebreak
### Vstructure over two binary parents
```{r}
levels <- list(0:1, 0:1)
labels <- list(rbind(0), rbind(0))
parts  <- bida:::partition_from_labels(labels, lengths(levels), levels)
cbind(expand.grid(levels), parts)
res <- run(parts, levels, r = 2, verbose = F)
```

```{r echo=FALSE}
plot_paired_comparison(res, subtitle = "Simple setting: V-structure")
plot_mse(res, subtitle = "Simple setting: V-structure")
```

\pagebreak
### Three binary parents
```{r}
levels <- list(0:1, 0:1, 0:1)
labels <- list(rbind(c(0, 0), c(1, 0)), 
               rbind(c(0, 0), c(1, 0)), 
               NULL)
parts  <- bida:::partition_from_labels(labels, lengths(levels), levels)

# print partition
cbind(expand.grid(levels), parts)
res <- run(parts, levels, r = 2, verbose = F)
```

```{r echo=FALSE}
plot_paired_comparison(res, subtitle = "Simple setting: Three binary variables")
plot_mse(res, subtitle = "Simple setting: Three binary variables")
```

\pagebreak
### Mixed cardinality
```{r}
levels <- list(0:1, 0:2, 0:3)
labels <- list(rbind(c(0, 0), c(1, 0)),
               rbind(c(0, 0), c(1, 0)), 
               rbind(c(0, 0), c(1, 0)))
parts  <- bida:::partition_from_labels(labels, lengths(levels), levels)
cbind(expand.grid(levels), parts)
res <- run(parts, levels, r = 3, verbose = F)
```

```{r echo=FALSE}
plot_paired_comparison(res, subtitle = "Simple setting: Mixed cardinality")
plot_mse(res, "Simple setting: Mixed cardinality")
```

\pagebreak
## Complex settings 

### Many binary variables, low CSI-complexity
```{r}
r <- 2
nlev  <- rep(r, 8)
levels <- lapply(nlev-1, seq.int, from = 0)

# sample a set of random partitions
set.seed(007)
parts <- replicate(10, 
                   rand_partition(nlev, 1, method = "dgraph", nextsplitprob = function(x) 1),
                   simplify = FALSE)

# compute relative number of rows 
c(true = prod(nlev), sapply(parts, function(x) length(unique(x))))
  
# run simulation for each parts
res <- list()
for (pp in seq_along(parts)) {
  cat("\nIter:", pp)
  res[[pp]] <- run(parts[[pp]], levels, r = r, reps = 1, verbose = F)
}

df <- do.call(rbind, res)
df$rep <- rep.int(seq_along(res), sapply(res, nrow))
```

```{r, echo = F}
plot_paired_comparison(df, subtitle = "Complex setting: 8 binary variables, low CSI-complexity, one random partition for each run.")
plot_Fmeasure(df, subtitle = "Complex setting: 8 binary variables, low CSI-complexity, one random partition for each run.")
plot_mse(df, subtitle = "Complex setting: 8 binary variables, low CSI-complexity, one random partition for each run.")
```

\pagebreak
### Many binary variables, high CSI-complexity
```{r}
r <- 2
nlev  <- rep(r, 8)
levels <- lapply(nlev-1, seq.int, from = 0)

# sample a set of random partitions
set.seed(007)
parts <- replicate(10, 
                   rand_partition(nlev, 1, method = "dgraph", nextsplitprob = function(x) .5),
                   simplify = FALSE)

vapply(parts, bida:::is_regular, nlev = nlev, logical(1))

# compute relative number of rows 
c(true = prod(nlev), sapply(parts, function(x) length(unique(x))))
  
# run simulation for each parts
res <- list()
for (pp in seq_along(parts)) {
  cat("\nIter:", pp)
  res[[pp]] <- run(parts[[pp]], levels, r = r, reps = 1, verbose = F)
}

df <- do.call(rbind, res)
df$rep <- rep.int(seq_along(res), sapply(res, nrow))
```

```{r, echo = F}
plot_paired_comparison(df, subtitle = "Complex setting: 8 binary variables, high-complexity, one random partition for each run.")
plot_Fmeasure(df, subtitle = "Complex setting: 8 binary variables, high-complexity,  one random partition for each run.")
plot_mse(df, subtitle = "Complex setting: 8 binary variables, , high-complexity, one random partition for each run.")
```

### High cardinality, low CSI-complexity
```{r}
r <- 4
nlev  <- rep(r, 4)
levels <- lapply(nlev-1, seq.int, from = 0)

# sample a set of random partitions
set.seed(007)
parts <- replicate(10, 
                   rand_partition(nlev, 1, method = "dgraph", nextsplitprob = function(x) 1),
                   simplify = FALSE)

# compute relative number of rows 
c(true = prod(nlev), sapply(parts, function(x) length(unique(x))))
  
# run simulation for each parts
res <- list()
for (pp in seq_along(parts)) {
  cat("\nIter:", pp)
  res[[pp]] <- run(parts[[pp]], levels, r = r, reps = 1, verbose = F)
}

df <- do.call(rbind, res)
df$rep <- rep.int(seq_along(res), sapply(res, nrow))
```

```{r, echo = F}
plot_paired_comparison(df, subtitle = "Complex setting: High-cardinality, low CSI-complexity, one random partition for each run.")
plot_Fmeasure(df, subtitle = "Complex setting: High-cardinality, low CSI-complexity, one random partition for each run.")
plot_mse(df, subtitle = "Complex setting: High-cardinality, low CSI-complexity, one random partition for each run.")
```

### High cardinality, high CSI-complexity
```{r}
r <- 4
nlev  <- rep(r, 4)
levels <- lapply(nlev-1, seq.int, from = 0)

# sample a set of random partitions
set.seed(007)
parts <- replicate(10, 
                   rand_partition(nlev, 1, method = "dgraph", nextsplitprob = function(x) .5),
                   simplify = FALSE)

# compute relative number of rows 
c(true = prod(nlev), sapply(parts, function(x) length(unique(x))))
  
# run simulation for each parts
res <- list()
for (pp in seq_along(parts)) {
  cat("\nIter:", pp)
  res[[pp]] <- run(parts[[pp]], levels, r = r, reps = 1, verbose = F)
}

df <- do.call(rbind, res)
df$rep <- rep.int(seq_along(res), sapply(res, nrow))
```

```{r, echo = F}
plot_paired_comparison(df, subtitle = "Complex setting: High-cardinality, high CSI-complexity, one random partition for each run." )
plot_Fmeasure(df, subtitle = "Complex setting: High-cardinality, high CSI-complexity, one random partition for each run.")
plot_mse(df, subtitle = "Complex setting: High-cardinality, high CSI-complexity, one random partition for each run.")
```
