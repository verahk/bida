% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/adjsets_from_dag.R
\name{adjsets_from_dag}
\alias{adjsets_from_dag}
\alias{adjset_from_bdag}
\alias{replace_large_adjsets}
\title{Identify adjustment sets in a dag}
\usage{
adjsets_from_dag(
  adjsets,
  dag,
  dmat = NULL,
  xvars = NULL,
  yvars = NULL,
  checksize = NULL,
  simplify = TRUE
)

adjset_from_bdag(adjset, bdag, dmat, x, y, anc, sets = NULL)

replace_large_adjsets(sets, checksize, bdag, dmat, x, y, anc)
}
\arguments{
\item{adjsets}{(character vector)
which adjset to identify. A subset of \code{c("anc", "pa", "pa_min", "o", "o_min")}.}

\item{dag}{(integer matrix)
\code{n-by-n} adjacency matrix, where \code{dag[i, j] = 1} indicates an edge from node \code{i} to node  \code{j}.}

\item{dmat}{(integer matrix)
adjacenecy matrix indicating ancestor relationships corresponding to \code{dag}.
Used to identify ancestors of the conditioning set in \code{find_nearest_adjset}.}

\item{xvars, yvars}{(integer vector, optional)
column position(s) of causes and effects for which adjustment sets should be identified.
If \code{NULL} the full sequence \code{1:n} is used.}

\item{checksize}{(function, optional)
to evaluate if an adjustment set it to large. Defaults to \code{NULL}. See details.}

\item{bdag}{(integer matrix)
adjacency matrix of backdoor graph w.r.t. a single cause \code{x}}

\item{x, y}{(integer)
column position of a cause variable \code{x} and effect variable \code{y}}

\item{anc}{(bolean vector)
indicator for the column position(s) of ancestors of \code{x} and \code{y}. rowSums(dmat\link{, c(x, y)}) > 0}

\item{sets}{(list, optional)
named list of valid adjustment sets. For avoiding repeated identification of
larger sets.}
}
\value{
\itemize{
\item \code{adjsets_from_dag}: a 3-dimensional list where element (\code{x}, \code{y}, \code{adjset}) is a
is the adjustment set of class \code{adjset} w.r.t. \code{x}, \code{y} and \code{dag}.
For every \code{x} that is not a cause of \code{y}, as indicated by \code{dmat[x, y] == 0},
the element (\code{x}, \code{y}, \code{adjset}) is \code{y}.
}

(integer vector)
column positions of the variables that consititutes the
adjustment set of class \code{adjset} w.r.t \code{x}, \code{y} in \code{bdag}.
}
\description{
Identify adjustment sets in a dag
}
\details{
\code{adjsets_from_dag} identifies all adjustment sets in \code{adjsets} for every
cause-effect pair given by \code{xvars} and \code{yvars}.

The adjustment sets are (w.r.t a cause-effect pair \verb{(x, y)}):
\itemize{
\item \code{anc}: Joint ancestors of \code{x} and \code{y}, excluding descendants of \code{x}.
\item \code{pa}: Parents of \code{x}.
\item \code{pa_min}: Minimal parent set of \code{x} w.r.t \code{y}.
\item \code{o}: o-set of \code{x} w.r.t \code{y}.
\item \code{o_min}: Minimal o-set of \code{x} w.r.t \code{y}.
}

Treatment of non-descendants:
\itemize{
\item if \code{dmat[x, y] = 0}, \code{y} is returned for the sets \verb{pa_min, o, o_min} (indicating a zero-effect).
}

Large adjustment sets:
If \code{checksize = NULL} no test for size of the set is applied (default).
Otherwise, if \code{checksize(x, y, z) = FALSE} the adjustment set is replaced with smaller,
valid set in this order:
\code{o} > \code{o_min} > \code{pa_min} > \code{NA}
If the minimal parent set (usually the smallest set) is too large, the
function return \code{NA}.

Identify a single adjustment set given the backdoor graph and joint ancestors.
Called from the wrapper \link{adjsets_from_dag}.
}
\examples{

# specify DAG row-wise:
dag <- rbind(Z1  = c(0, 0, 0, 1, 0, 0, 0),
             Z2  = c(0, 0, 0, 1, 0, 0, 0),
             L   = c(0, 1, 0, 0, 1, 0, 0),
             X   = c(0, 0, 0, 0, 1, 0, 0),
             M   = c(0, 0, 0, 0, 0, 1, 0),
             Y   = c(0, 0, 0, 0, 0, 0, 0),
             U   = c(0, 0, 0, 0, 0, 1, 0))
colnames(dag) <- rownames(dag)
g <- graph::graphAM(dag, edgemode = "directed")


# compute adjustment set w.r.t. X and Y
x <- 4
y <- 6
adjsets <- c("max", "pa","pa_min", "o", "o_min")
sets <- bida:::adjsets_from_dag(adjsets, dag, xvars = x, yvars = y)

# plot each adjustment set
color <- c("grey", "lightblue",  "blue", "pink", "red")
names(color) <- adjsets
par(mfrow = c(1, 5),
    mar = c(5, 1, .1, .1))

for (a in names(sets)) {
  z <- sets[[a]]
  tmp <- rep(color[a], length(z))
  names(tmp) <- colnames(dag)[z]
  Rgraphviz::plot(g,
                  nodeAttrs = list(fillcolor = tmp),
                  main = a)
}



# define function for testing adjustment set size
test_adjset_size_cat <- function(adjset, x, y, z, testarg) {
  is.na(z) || prod(testarg$nlev[c(x, y, z)]) < testarg$maxconf
}

adjsets <- c("pa", "o", "o_min", "pa_min")
adjsets_from_dag(adjsets, dag)


checksize <- list()
checksize$fun <- check_adjset_size_cat <- function(adjset, x, y, z, checksize) {
  is.na(z) || prod(checksize$nlev[c(x, y, z)]) < checksize$maxconf
}
checksize$maxconf <- 10
}
\seealso{
\link{find_nearest_adjset}
}
