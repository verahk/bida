% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bida_pair.R, R/bida_pair_cat.R
\name{bida_pair}
\alias{bida_pair}
\alias{posterior_mean.bida_pair_cat}
\alias{posterior_sample.bida_pair_cat}
\title{Class: \code{bida_pair}}
\usage{
bida_pair(type, data, x, y, sets, support, hyperpar, lookup = NULL)

\method{posterior_mean}{bida_pair_cat}(x, n = 10^3, ace_funs = NULL)

\method{posterior_sample}{bida_pair_cat}(x, n = 10^3, ace_funs = NULL)
}
\arguments{
\item{data}{a N-by-n data matrix}

\item{x}{(integer)
column position of cause variable}

\item{y}{(integer)
column position of effect variable}

\item{sets}{(integer matrix)
each row contains column positions of a valid adjustment set.
NA entries in each row is ignored.}

\item{support}{(numeric vector)
a vector with support for each adjustment set. Should be of length \code{nrow(sets)}
and the entries should sum to 1 (not checked).}

\item{hyperpar}{list of parameters, depending on the prior distribution. See details.}
}
\value{
An object of class \link{bida_pair} is a list that contains:
\itemize{
\item \code{params}:
\item \code{support}:
\item \code{zerosupp}:
}

\itemize{
\item \code{posterior_sample}: A kx-by-ky matrix with posterior mean values.
}

\itemize{
\item \code{posterior_sample}: if \code{ace_funs == NULL} a three dimensional array with IPTs.
Otherwise a matrix with the
}
}
\description{
Defines a posterior mixture distribution over the
parameters defining intervention distribution p(y|do(x)).
}
\details{
The \code{hyperpar} argument is a list that contains parameters of the distribution
or other variables required to update the parameters.
\itemize{
\item Categorical data:
\itemize{
\item \code{nlev} (integer vector) cardinality of each variable.
\item \code{ess} (numeric) imaginary sample size.
Also, if type \code{ldag} or \code{tree}, parameters for optimizing a partition of the CPT.
See \link{optimize_partition}.
}
}
}
\examples{

x <- 1 # cause node
y <- 2 # effect node

# construct parent sets
sets <- matrix(NA, 4, 2)
sets[1, ]          # no parents
sets[2, 1] <- 3    # single parent
sets[3, ]  <- 3:4  # multiple parents
sets[4, 1] <- y    # parent set includes node `y`
sets

# uniform support over all sets
support <- rep(1/nrow(sets), nrow(sets))

# categorical data ----
nlev <- 1:4 +1
lev  <- lapply(nlev-1, seq.int, from = 0)
data <- as.matrix(expand.grid(lev))
hyperpar <- list(nlev = nlev,  levels = lev, ess = 1)

pair <- bida_pair("cat", data, x, y, sets, support, hyperpar)
str(pair, max.level = 1)


# compute posterior mean
posterior_mean(pair)
posterior_mean(pair, contrasts = list(jsd = JSD))
stopifnot(all(dim(posterior_mean(pair)) == nlev[c(y, x)]))

# sample from postrior
posterior_sample(pair, n = 10)

}
