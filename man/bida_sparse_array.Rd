% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bida_sparse_array.R
\name{bida_sparse_array}
\alias{bida_sparse_array}
\alias{new_bida_sparse_array}
\alias{as.array.bida_sparse_array}
\alias{aperm.bida_sparse_array}
\title{class: cida sparse array}
\usage{
new_bida_sparse_array(value, index, dim, dimnames = NULL)

\method{as.array}{bida_sparse_array}(x)

\method{aperm}{bida_sparse_array}(x, perm)
}
\arguments{
\item{index}{(integer vector) position of non-zero elements}

\item{x}{(numeric vector) values of non-zero elements}

\item{dims}{(integer vector) dimension of array}
}
\value{
an object of class \code{bida_sparse_array}
}
\description{
Sparse representation of multi-dimensional arrays.
}
\examples{

vals <- seq(3, 27, by = 3)
x <- new_bida_sparse_array(vals, vals-1, c(3, 3, 3))
y <- as.array(x)
y

dims <- 2:4
x <- new_bida_sparse_array(rep(1, prod(dims)), seq_len(prod(dims))-1, dims)
y <- aperm(x, c(3:1))
stopifnot(all.equal(as.array(y), aperm(as.array(x), c(3:1))))


# compare size of sparse and non-sparse arrays
obj_size <- matrix(NA, 10, 2)
sparsity <- .25 # share of non-zero elements
for (i in seq_len(nrow(obj_size))) {
  dims <- rep(2, i)
  index  <- sample(prod(dims), round(prod(dims)*sparsity))
  counts <- sample(10, size = length(index), replace = T)

  sparse <- new_bida_sparse_array(counts, index, dims)
  arr    <- as.array(sparse)
  obj_size[i, 1] <- pryr::object_size(sparse)
  obj_size[i, 2] <- pryr::object_size(arr)
}

matplot(obj_size, type = "l", log = "y")
}
\keyword{internal}
