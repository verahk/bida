% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/optimize_partition.R,
%   R/optimize_partition_ldag.R, R/optimize_partition_tree.R
\name{optimize_partition}
\alias{optimize_partition}
\alias{optimize_partition_ldag}
\alias{optimize_partition_tree}
\title{Optimize partition over parent outcome space}
\usage{
optimize_partition(
  counts,
  levels,
  ess,
  method,
  regular = FALSE,
  verbose = FALSE
)

optimize_partition_ldag(
  counts,
  levels,
  ess,
  regular,
  min_score_improv = 0,
  P = as.list(1:nrow(counts) - 1),
  labels = rep(list(integer()), length(levels)),
  conf = as.matrix(expand.grid(levels)),
  verbose = FALSE
)

optimize_partition_tree(
  counts,
  levels,
  ess = 1,
  min_score_improv = 0,
  prune = FALSE,
  verbose = verbose
)
}
\arguments{
\item{counts}{(integer matrix)
a frequency table.}

\item{levels}{(list of integer vectors)
levels of each conditioning variable in \code{counts},
such that \code{expand.grid(levels)} gives the joint configurations corresponding
to each row in \code{counts}.}

\item{ess}{(numeric)
imaginary sample size for the bdeu-prior.}

\item{method}{(character)}

\item{regular}{(logical)
if \code{FALSE} (default) the optimized partition is returned, also if it implies
conditional independencies (is not "regular"). If \code{TRUE} each part of the
optimized partition is divided by the outcomes of the relevant variables.
See \code{\link[=make_regular]{make_regular()}}.}

\item{verbose}{(logical)}
}
\value{
a list with named elements:
\itemize{
\item \code{partition}: the partition implied by the tree
\item \code{scores}: each part's contribution to the local score
\item additional output from the different optimization procedures.n
}
}
\description{
Optimize a regression-tree partitioning of the conditional outcome space.
}
\examples{


# non-binary-split-CSI
levels <- list(0:1, 0:1)
counts <- cbind(c(100, 10, 10, 10), c(10, 100, 100, 100))

tree = optimize_partition(counts, levels, 1, "tree")
ldag = optimize_partition(counts, levels, 1, "ldag")
part = optimize_partition(counts, levels, 1, "part")

cbind(expand.grid(levels),
      counts,
      get_parts(tree$partition),
      get_parts(ldag$partition),
      get_parts(part$partition))

# mixed cardinality
levels <- list(0:1, 0:2, 0:3)
r <- 3
q <- prod(lengths(levels))
counts <- cbind(1, 10, 10*rep.int(0:5, q/5))

tree = optimize_partition(counts, levels, 1, "tree")
ldag = optimize_partition(counts, levels, 1, "ldag")

cbind(expand.grid(levels),
      counts,
      get_parts(tree$partition),
      get_parts(ldag$partition))

cbind(expand.grid(levels),
      counts,
      get_parts(tree$partition),
      get_parts(ldag$partition))

# non-regular partitions
levels <- list(0:1, 0:1)
counts <- cbind(c(10, 10, 10, 10), c(100, 100, 100, 100))

tree = optimize_partition(counts, levels, 1, "tree", regular = F)
ldag = optimize_partition(counts, levels, 1, "ldag", regular = F)
part = optimize_partition(counts, levels, 1, "part", regular = F)

cbind(expand.grid(levels),
      counts,
      get_parts(tree$partition),
      get_parts(ldag$partition),
      get_parts(part$partition))

# force regular structure
tree = optimize_partition(counts, levels, 1, "tree", regular = T)
ldag = optimize_partition(counts, levels, 1, "ldag", regular = T)
part = optimize_partition(counts, levels, 1, "part", regular = T)

cbind(expand.grid(levels),
      counts,
      get_parts(tree$partition),
      get_parts(ldag$partition),
      get_parts(part$partition))




levels <- list(0:1, 0:1)
counts <- cbind(10, c(10, 100, 1000, 1000))
ess <- 1
optimize_partition_tree(counts, levels, ess, min_score_improv = 0, verbose = TRUE)


# illustrate grow-full-and-then-prune procedure
levels <- list(0:1, 0:1, 0:1)
counts <- cbind(c(1, 1, 1, 1, 10, 20, 20, 2), c(1, 1, 1, 1, 10, 2, 2, 10))

## stop splitting when additional split do not improve score (default)
fit <- optimize_partition_tree(counts, levels, ess, min_score_improv = 0, verbose = TRUE)
cbind(counts, part = get_parts(fit$partition))
sum(fit$scores)

##  grow full tree
fit <- optimize_partition_tree(counts, levels, ess, min_score_improv = -Inf, verbose = TRUE)
cbind(counts, part = get_parts(fit$partition))
sum(fit$scores)

## grow full tree, then prune
fit <- optimize_partition_tree(counts, levels, ess, min_score_improv = -Inf, TRUE, verbose = TRUE)
cbind(counts, part = get_parts(fit$partition))
sum(fit$scores)

# sparse counts - split on var 2
levels <- list(0:2, 0:2)
counts <- cbind(c(rep(1, 3), rep(0, 6)),
                c(rep(0, 6), rep(1, 3)),
                rep(0, 9))
fit <- optimize_partition_tree(counts, levels, ess, min_score_improv = 0, verbose = TRUE)
cbind(counts, part = get_parts(fit$partition))
sum(fit$scores)


}
